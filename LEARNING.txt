Defining a Local Class
Objective

After completing this lesson, you will be able to define a local class inside a global class.
Local Classes
Local And Global Classes
Classes in ABAP can be either local or global.


Global classes are stored centrally and are contained in their own repository object called a class pool. A global class can serve as main program. Global classes can also contain logic to be reused by other ABAP programs, including other global classes.

Local classes are defined as part of an ABAP program, for example a global class. You can use them only in the program or class in which they are defined. Local classes are useful for entities or functions that you only need in a single program.

The ABAP syntax of both local and global classes is almost identical. In this course, you will be working with local classes in your global class. The global class with method if_oo_adt_classrun~main will only serve as a kind of main program.

Local Classes in Global Classes
As shown in the figure below, when you open a global class in ADT, the focus is on tab Global Class, first. Here you find the source code of the global class itself. To see or enter the source code of local classes, you have to navigate to tab Local Types.


ADT provides a source code template for local class. To use this template proceed as follows:

In the ABAP editor, type lcl and press Ctrl + Space.
From the list that displays choose lcl - Local class and press Enter.
Adjust the name of the new local class.
For the classes in this course you have to remove the create private addition from the CLASS … DEFINITION statement.

How To Create A Local Class In A Global Class
Demo
Start Demo
Attributes
Source Code of a Class in ABAP

In ABAP. the source code of a class has two parts - the definition and the implementation. The definition part of a class is subdivided into up to three sections, called the visibility sections of the class.

Definition
The definition part of a class contains the definition and declaration of all of the elements in the class, that is, the types, the constants, the attributes, and the methods. It begins with CLASS <class_name> DEFINITION. and ends with ENDCLASS.
Implementation
The implementation part of a class contains the executable code of the class, namely the implementation of its methods. It begins with CLASS <class_name> IMPLEMENTATION. and ends with ENDCLASS. The implementation part of a class is optional. It becomes mandatory as soon as the class definition contains executable methods.
Visibility sections
Each visibility section of a class starts with one of the statements PUBLIC SECTION, PROTECTED SECTION, PRIVATE SECTION and ends implicitly when the next section begins. The last section ends with statement ENDCLASS. All declarations of a class have to be inside one of the sections. In other words: No declarations are allowed between the beginning of the class definition and the beginning of the first section.

The section in which a declaration is located defines the visibility of the declared element of the class.

The three visibility sections of a class are optional; if you do not need a particular section, you do not have to declare it. But if a class definition consists of more than one section, they must follow the order PUBLIC SECTION - PROTECTED SECTION - PRIVATE SECTION.

Definition Part of a Class
The following video shows the different kinds of components you can define in a class. You can define any of these components in any visibility section of the class.

Example: Attributes of the Flight Connection Class

Let us start implementing our UML model in ABAP, and take the attributes of the connection class to begin with. To declare an attribute, use the DATA statement within the appropriate visibility section.

The attribute conn_counter is underlined, which denotes a static attribute. You declare static attributes using the CLASS-DATA statement. The syntax of CLASS-DATA is identical to that of DATA.

Note

We begin with public attributes at this point. Later in the course, when we discuss encapsulation, we will turn them into private attributes.
Define a Local Class
In this exercise, you define a local class inside of a global class.

Template:
none
Solution:
/LRN/CL_S4D400_CLS_LOCAL_CLASS (global Class)
Task 1: Create a Global Class
In your own package, create a new ABAP class.

Steps
Create a new global class that implements interface IF_OO_ADT_CLASSRUN (suggested name: ZCL_##_LOCAL_CLASS, where ## stands for your group number).

Choose File→New→ABAP Class.

Enter the name of your package in the Package field. In the Name field, enter the name ZCL_##_LOCAL_CLASS, where ## is your group number. Enter a description.

In the Interfaces group box, choose Add.

Enter IF_OO_ADT_CLASSRUN. When the interface appears in the hit list, double-click it to add it to the class definition.

Choose Next.

Select your transport request and choose Finish.

Task 2: Define a Local Class
Define a local class lcl_connection and declare some public attributes.

Steps
Inside the global class, create a new local class lcl_connection. Use code completion to generate the code, but make sure you remove the create private addition from the generated code.

Switch to the Local Types tab.

Type lcl into the editor and press Ctrl + Space.

Double-click lcl - class in the pop-up.

While there is still a frame visible around lcl in the line class lcl definition create private., complete the name of the class to lcl_connection.

Delete the words create private at the end of the code row class lcl_connection definition..

In local class lcl_connection, declare the following public attributes:

Attributes
Attribute Name	Scope	Data Type
carrier_id	instance	/DMO/CARRIER_ID
connection_id	instance	/DMO/CONNECTION_ID
conn_counter	static	I
After line PUBLIC SECTION. and before line PROTECTED SECTION., add the following code:

Code Snippet

Copy code

Switch to dark mode

   DATA carrier_id    TYPE /dmo/carrier_id.
   DATA connection_id TYPE /dmo/connection_id.

   CLASS-DATA conn_counter TYPE i.
Activate the class.

Note

Because the if_oo_adt_classrun~main method does not contain executable code, yet, there is nothing to test or debug at this point.
Press Ctrl + F3 to activate the class.

Compare your code on tab Local Types to the following extract from the model solution:

Code Snippet

Copy code

Switch to dark mode

*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations

CLASS lcl_connection DEFINITION.

  PUBLIC SECTION.

    DATA carrier_id    TYPE /dmo/carrier_id.
    DATA connection_id TYPE /dmo/connection_id.

    CLASS-DATA conn_counter TYPE i.

  PROTECTED SECTION.
  PRIVATE SECTION.

ENDCLASS.

CLASS lcl_connection IMPLEMENTATION.

    ENDCLASS.

Creating Instances of a Class
Objective

After completing this lesson, you will be able to create Instances of an ABAP Class.
Instance Creation

You work with attributes like normal variables of the same type. Outside the class, however, the attribute name is not sufficient to identify the attribute unambiguously. To address a static attribute outside the class, first type the class name, then the static component selector (=>), and only then the attribute name. The static component selector is a double arrow made up of an equals sign and the greater than sign.

Hint

No blanks are allowed before or after the component selector.

For instance attributes the situation is even more complicated: In order to access an instance component, you need a reference variable.

A reference variable is a special kind of variable that you use to create, address, and manage an object. A reference variable is used to point at the instance of a class in the program memory. You declare reference variables using the DATA statement with the addition TYPE REF TO followed by the name of a class.

The initial value of a reference variable is called the NULL reference; the reference does not yet point anywhere.


To create a new instance of a class, you use the NEW operator. The example above, uses a NEW #( ) expression on the right hand side of a value assignment. The result of the expression is the memory address of the newly created instance. This reference is then stored in the reference variable on the left-hand side of the assignment.

You may have noticed that the name of the class that you want to instantiate does not appear anywhere in the expression. However, from the location of the NEW #( ) expression, the system already knows that the target variable connection has the type REF TO lcl_connection, and consequently it knows that it should create an instance of the class lcl_connection. The pound sign after the NEW operator means "use the type of the variable before the equals sign". (In more advanced scenarios, you can actually specify the name of the class in place of the pound sign).

Hint

There must be at least one blank between the brackets.
When you address a class for the first time (which could be accessing a static component or creating an instance of the class), the runtime system also loads the class definition into the program memory. This class definition contains all of the static attributes, which only exist once in the class instead of once for each instance.


You address static components using the class name and the static component selector. This does not work for instance components because you have to specify the instance you want to access.

To address an instance attribute outside the class, first type the reference variable, then the instance component selector (->), and only then the attribute name. The instance component selector is an arrow made up of a dash and the greater than sign.

Note

Unlike many other programming languages, ABAP uses different characters for instance component selector and static component selector.

One of the main characteristics of object oriented programming is the fact that you can create multiple instances of the same class. Each instance is created in a different place in the program memory and the values of instance attributes in one instance are independent from the values in other instances. But as the graphic illustrates, instances of the same class share the value for the static attributes.


If you assign one reference variable to another, the system copies the address of the object to which the first variable is pointing into the second reference variable. The result of this is that you have two reference variables that point to the same object.


You can use the same reference variable to create more than one instance of a class. Each time you use the NEW #( ) expression, the system creates a new instance of the class and places the address of the new instance into the reference variable. However, the address of the new instance overwrites the address of the previous instance.

In the example above, the address of lcl_connection (2) overwrites the address of lcl_connection (1). Consequently, there is no longer a reference variable in the program pointing to lcl_connection (1). When this happens to an instance, it can no longer be addressed from the program.

To prevent the program memory from becoming filled with objects that can no longer be addressed and eventually overflowing, the runtime system has a component called the garbage collector. The garbage collector is a program that runs periodically to look for and destroy objects to which no more references point. If during a program you delete the last reference to an object by overwriting it or using the CLEAR statement, the garbage collector will destroy the object on its next pass.

Note

At the end of a program, when all of the reference variables are freed, the garbage collector will destroy all of the instances to which they had pointed. You do not have to worry about resource management in the program yourself.
How to Create Instances of an ABAP Class
Demo
Start Demo
Instance Management in an Internal Table

One way in which you can keep objects alive is to place the references into an internal table. This is a technique that you may well want to use if you are creating a whole series of objects. It enables you to use a single reference variable to create lots of objects. Although the reference variable is overwritten with the address of the next object, the existing objects are safe because the internal table contains a reference to them. You therefore never delete the "last" reference to the objects.

How To Manage Instances in an Internal Table
Demo
Start Demo
Create and Manage Instances
In this exercise, you create and manage instances of your local class.

Template:
/LRN/CL_S4D400_CLS_LOCAL_CLASS (global Class)
Solution:
/LRN/CL_S4D400_CLS_INSTANCES (global Class)
Task 1: Copy Template (Optional)
Copy the template class. If you finished the previous exercise you can skip this task and continue editing your class ZCL_##_LOCAL_CLASS.

Steps
Open the source code of global class/LRN/CL_S4D400_CLS_LOCAL_CLASS in the ABAP editor.

In the Eclipse toolbar, choose Open ABAP Development Object. Alternatively, press Ctrl + Shift + A.

Enter /LRN/CL_S4D400_CLS as search string.

From the list of development objects choose /LRN/CL_S4D400_CLS_LOCAL_CLASS, then choose OK.

Link the Project Explorer view with the editor.

In the Project Explorer toolbar, find the Link with Editor button. If it is not yet pressed, choose it. As a result, the development object, that is open in the editor, should be highlighted in the Project Explorer.

Copy class /LRN/CL_S4D400_CLS_LOCAL_CLASS to a class in your own package (suggested name: ZCL_##_INSTANCES, where ## stands for your group number).

In the Project Explorer view, right-click class /LRN/CL_S4D400_CLS_LOCAL_CLASS to open the content menu.

From the context menu, choose Duplicate ....

Enter the name of your package in the Package field. In the Name field, enter the name ZCL_##_INSTANCES, where ## stands for your group number.

Adjust the description and choose Next.

Confirm the transport request and choose Finish.

Task 2: Create an Instance
In the main method of your global class, declare a reference variable and create an instance of your local class.

Steps
In method if_oo_adt_classrun~main of your global class, declare a reference variable (suggested name: connection) and type it with your local class lcl_connection.

Switch to the Global Class tab.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

  METHOD if_oo_adt_classrun~main.

    DATA connection TYPE REF TO lcl_connection.

  ENDMETHOD.
Create an instance of the class and set the attributes carrier_id and connection_id (Suggested values: "LH" for attribute carrier_id and "0400" for attribute connection_id.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

  DATA connection TYPE REF TO lcl_connection.

  connection = new #( ). 

  connection->carrier_id    = 'LH'.
  connection->connection_id = '0400'.
Hint

After typing the component selector (->), press Strg + Space to choose the attribute names from a suggestion list.
Activate the class and use the debugger to analyze step by step what happens.

Press Ctrl + F3 to activate the class.

Double-click the left-hand margin of the editor next to the line connection = new #( ).to set a break point.

Press F9 to run the class.

Double-click the word connection to display the content of reference variable connection.

Press F5 to go one step further in the debugger. Check that the value of connection has changed.

In the Variablesview, expand the branch connection to display the initial attributes of the class.

Press F5 to go one step further in the debugger. Check that the value of carrier_id has changed.

Press F5 again. Check that the value of Connection_ID has changed.

Task 3: Manage Several Instances
Create more instances of your local class and store the references to these instances in an internal table.

Steps
In method if_oo_adt_classrun~main( ) of your global class, declare an internal table with the line type TYPE REF TO lcl_connection (suggested name: connections).

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

  DATA connection TYPE REF TO lcl_connection.
  DATA connections TYPE TABLE OF REF TO lcl_connection.

  connection = new #( ). 

  connection->carrier_id    = 'LH'.
  connection->connection_id = '0400'.
After instantiating the class and setting the attributes, append the object reference to the internal table.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

   connection = NEW #( ).

   connection->carrier_id = 'LH'.
   connection->connection_id = '0400'.

   APPEND connection TO connections.

 
Create two more instances of class lcl_connection, set their instance attributes to different values than in the first instance and append the references to the new instances to internal table connections. Use the same reference variable connection for all three instances.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

    connection = NEW #(  ).

    connection->carrier_id    = 'LH'.
    connection->connection_id = '0400'.

    APPEND connection TO connections.

    connection = NEW #(  ).

    connection->carrier_id    = 'AA'.
    connection->connection_id = '0017'.

    APPEND connection TO connections.

    connection = NEW #(  ).

    connection->carrier_id    = 'SQ'.
    connection->connection_id = '0001'.

    APPEND connection TO connections.
Activate the class and use the debugger to analyze step by step what happens.

Press Ctrl + F3 to activate the class.

Double-click the left-hand margin of the editor next to the first line connection = new #( ).to remove the break point.

Double-click the left-hand margin of the editor next to the first line APPEND connection TO connections.to set a new break point.

Press F9 to run the class.

Double-click the word connection to display the content of reference variable connection.

Double-click the word connections to display the content of internal table connections.

Press F5 to go one step further in the debugger. Check that the content of connections has changed.

In the Variables view, expand the branch connections to display content of the internal table.

Press F5 several times until you reach the end of the program. While you do so, check the content of the internal table.

Compare your code on tab Global Class to the following extract from the model solution:

Code Snippet

Copy code

Switch to dark mode

METHOD if_oo_adt_classrun~main.

    DATA connection TYPE REF TO lcl_connection.
    DATA connections TYPE TABLE OF REF TO lcl_connection.

* First Instance
**********************************************************************

    connection = NEW #(  ).

    connection->carrier_id    = 'LH'.
    connection->connection_id = '0400'.

    APPEND connection TO connections.

* Second Instance
**********************************************************************
    connection = NEW #(  ).

    connection->carrier_id    = 'AA'.
    connection->connection_id = '0017'.

    APPEND connection TO connections.

* Third Instance
*******************************************

Defining and Calling Methods
Objective

After completing this lesson, you will be able to define and call methods.
Method Definition

In the definition part of a class you use METHODS to define an instance method and CLASS-METHODS to define a static method. The name of the method is followed by the method's signature; that is, the set of values that the method exchanges with its caller and the exceptions that may arise during the method.

The signature of a method consists of parameters and exceptions. Each parameter has a name and a type.

ABAP knows the following kinds of parameters:

Importing Parameters
Importing parameters are values that the method receives from the caller. A method can have any number of importing parameters.

By default, importing parameters are mandatory, but there are two ways to make them optional:

Using the OPTIONAL addition. The parameter is optional and its default value is the initial value appropriate to the type of the parameter
Using the DEFAULT <val> addition. The parameter is optional and its default value is the value that you specified as <val>.
Inside of a method, you may not change importing parameters. If you attempt to do so, you will cause a syntax error.

Exporting Parameters
Exporting parameters are results that are returned by the method. A method can have any number of exporting parameters. All exporting parameters are optional - a calling program only uses the values that it actually needs.

Changing Parameters
Changing parameters are values that the method receives from the caller. Unlike importing parameters, the method can change the values of these parameters. They are then returned to the caller under the same name. A method can have any number of changing parameters. Changing parameters are mandatory by default; you can make them optional in the same way as importing parameters.

Returning Parameters
A returning parameter is a method result that can be used directly in an expression. A method can only have one returning parameter. Returning parameters have to use a special form of parameter passing which is called pass-by-value. This form of parameter passing is defined by surrounding the parameter name in brackets (no blanks!) and preceding it with keyword VALUE.

Keyword RAISING is used to list the exceptions the method might raise to indicate an error situation. The calling program can then react to the error.


As an example, add two methods to our class lcl_connection.

A set_attributes( ) method to set the values for attribute i_carrier_id and i_connection_id and a get_attributes( ) method to return the values of these attributes. Where set_attributes( ) needs two importing parameters, one for each of attribute, the get_attributes( ) method needs two exporting parameters.

For every method that you define, you must also create an implementation in the implementation part of the class. Until you do so, you see syntax errors in your class; the syntax check tells you that the implementation of the method is missing.

Hint

ADT offers a quickfix to add the missing implementation. To use this quick fix, proceed as follows:
Position the cursor in a METHODS statement with an error and press Ctrl + 1.
From the list of possible quick fixes choose Add implementation for … and press Enter . If the implementation is missing for several methods, the quickfix title reads Add … unimplemented methods.
How to Define Methods
Demo
Start Demo
Method Implementation

You must implement every method that you define. You do this in the implementation part of the class, by adding a pair of statements METHOD <method_name> and ENDMETHOD.

The method implementation contains ABAP statements that can access the parameters of the method (you are not allowed to change importing parameters) and all types, attributes, and constants that you declared in the class, independent from their visibility. Instance methods may access both instance attributes and static attributes. Static methods may only access static components.

Inside the implementation part of a class, you can access the attributes of that class without a reference variable and '->' (or the class name and '=>' , in case of static attributes).


Only in the implementation of instance methods, ABAP offers built-in variable ME. ME is a reference variable, typed with the current class and filled at runtime with the address of the current instance. The use of ME is optional and should be avoided, unless the name of an attribute collides with the name of another data object, for example a parameter name.

In the example, the import parameters of method set_attributes( ) have the same names as the corresponding attributes. In such a situation, the name by itself denotes the parameter. Only by putting me-> in front it becomes clear that an attribute of the current instance is to be accessed.


If an error occurs during the execution of a method, the method can trigger an exception using statement RAISE EXCEPTION TYPE, followed by the name of the exception.

Note

Technically, exception names are the names of special ABAP classes and statement RAISE EXCEPTION TYPE creates an instance of the referenced class. The instance is referred to as exception object and the special kind of ABAP classes are called exception classes.
The moment an exception is raised, the method execution is terminated.

Control is returned to the calling program if all prerequisites are met. Otherwise the entire program terminates with a runtime error.

The prerequisites for continuing the program are as follows:

The raised exception is declared in the RAISING clause of the method signature
The method call is surrounded by a TRY … ENDTRY control structure
The TRY … ENDTRY control structure contains a CATCH block for the exception
Note

For some exceptions, the ABAP editor displays a syntax warning with a quick fix when you raise an exception that is not yet declared in the RAISING clause of the method.
How to Implement Methods
Demo
Start Demo
Method Calls

You call an instance method using a reference variable and the instance component selector (->). The component selector is followed by the name of the method you want to call. For static methods you use the class name and the static component selector (=>). On both cases, the parameter passing takes place in a pair of brackets. The brackets are needed in any case. They remain empty if no parameters are to be passed.

Note

No blank is allowed between the method name and the opening bracket. On the other hand you need at least one blank after the opening bracket and before the closing bracket.
Importing parameters are listed after keyword EXPORTING because the values that are imported by the called method are exported by the calling program. The parameter names are listed on the left-hand side of an equals sign (=) and an expression on the right-hand side.. This expression can be as simple as a literal, constant, or variable but any other expressions are also allowed as long as the type of the expression matches the type of the parameter.

Exporting parameters are listed after keyword IMPORTING. Note, that for exporting parameter the parameter name is also listed on the left-hand side of the equals sign. The variable on the right-hand side has to have the same type as the parameter.

Changing parameters are listed after keyword CHANGING. The type of the variable on the right-hand side has to match the type of the parameter on the left hand side.


The example illustrates the call of instance methods set_attributes( ) and get_attributes( ). The parameter names are always on the left-hand side of the equals sign (=).

Hint

You can use code completion in ADT to generate the method call including the parameter passing. To do so, proceed as follows:

Type in the reference variable (or class name) and the component selector.
Once you typed the component selector press Ctrl + Space to display a list of components you can address.
If you choose a method, and press Shift + Enter to insert the name of the method and its full signature into your code. Optional parameters are listed in comment lines.

When calling a method, keyword IMPORTING is always needed to receive the value of exporting parameters. But keyword EXPORTING becomes optional, if you only want to supply importing parameters.

For methods with only one mandatory importing parameter, you can even omit the explicit parameter assignment. In the example, parameter i_carrier_id is optional with default value 'LH'. Therefore the value between the brackets is assigned to the remaining mandatory importing parameter i_connection_id.

How to Call Methods
Demo
Start Demo
Exception Raising

In a previous section of this class, you learned how to handle runtime errors with TRY … ENDTRY control structures.

Exceptions declared in the RAISING clause of a method definition are handled in exactly the same way:

Place the method call in the TRY-block of the TRY … ENDTRY control structure.
Define a CATCH block with the name of the exception you want to handle.
Note

If there is code that you want to skip in case the method call failed, you can place this code inside the try block, after the method call.
Try It Out: Method Calls and Exception Handling
Like in the first exercise of this course, create a new global class that implements interface IF_OO_ADT_CLASSRUN.
Copy the following code snippet to the implementation part of method if_oo_adt_classrun~main( ):
Code Snippet

Copy code

Switch to dark mode

    CONSTANTS c_carrier_id TYPE /dmo/carrier_id       VALUE 'LH'.
    CONSTANTS c_connection_id TYPE /dmo/connection_id VALUE '0400'.

    DATA connection  TYPE REF TO lcl_connection.
    DATA connections  TYPE TABLE OF REF TO lcl_connection.

* Create Instance
**********************************************************************

    connection = NEW #(  ).

* Call Method and Handle Exception
**********************************************************************
    out->write(  |i_carrier_id    = '{ c_carrier_id }' | ).
    out->write(  |i_connection_id = '{ c_connection_id }'| ).

    TRY.
        connection->set_attributes(
          EXPORTING
            i_carrier_id    = c_carrier_id
            i_connection_id = c_connection_id
        ).

        APPEND connection TO connections.
        out->write( `Method call successful` ).
      CATCH cx_abap_invalid_value.
        out->write( `Method call failed`     ).
    ENDTRY.  
Navigate to tab Local Typesand insert the following code snippet there:
Code Snippet

Copy code

Switch to dark mode

CLASS lcl_connection DEFINITION.
  PUBLIC SECTION.

* Attributes
    DATA carrier_id    TYPE /dmo/carrier_id.
    DATA connection_id TYPE /dmo/connection_id.

* Methods
    METHODS set_attributes
      IMPORTING
        i_carrier_id    TYPE /dmo/carrier_id  DEFAULT 'LH'
        i_Connection_id TYPE /dmo/connection_id
      RAISING
        cx_abap_invalid_value.


ENDCLASS.

CLASS lcl_connection IMPLEMENTATION.

  METHOD set_attributes.

    IF i_carrier_id IS INITIAL OR i_connection_id IS INITIAL.
      RAISE EXCEPTION TYPE cx_abap_invalid_value.
    ENDIF.

    carrier_id    = i_carrier_id.
    connection_id = i_connection_id.

  ENDMETHOD.

ENDCLASS.
Press CTRL + F3 to activate the class and F9 to execute it as a console app.
Analyze the console output. Debug the program, play around with the source code to get familiar with the concepts. In particular, change the values of the two constants to debug the raising of the exception.
Functional Methods

Methods that have a returning parameter are called functional methods. It is not possible to define more than one returning parameter for the same method. It is mandatory that you define the returning parameter in the form VALUE(<parameter_name>). Besides the returning parameter a functional method can have any combination of other parameters. It is most common however, to add importing parameters only. The reason is, that with additional exporting or changing parameters you loose the biggest advantage of functional methods, namely, that you can use the result of a functional method directly in other ABAP expressions.

The figure shows two examples of how you can use functional methods in expressions; the first is a simple example in which the returning parameter is assigned directly to a variable. The second example shows how the call of the functional method is used as input for another method. The system executes the functional method, and then uses the value of the returning parameter as input for method write( ).

Try It Out: Functional Methods
Like in the first exercise of this course, create a new global class that implements interface IF_OO_ADT_CLASSRUN.
Copy the following code snippet to the implementation part of method if_oo_adt_classrun~main( ):
Code Snippet

Copy code

Switch to dark mode

   DATA connection  TYPE REF TO lcl_connection.
   DATA connections  TYPE TABLE OF REF TO lcl_connection.

* Create Instance
**********************************************************************

    connection = NEW #(  ).

    connection->set_attributes(
      EXPORTING
        i_carrier_id    = 'LH'
        i_connection_id = '0400'
    ).

    APPEND connection TO connections.

* Calling Functional Method
**********************************************************************
    " in a value assignment (with inline declaration for result)
    DATA(result) = connection->get_output( ).

    " in logical expression
    IF connection->get_output(  ) IS NOT INITIAL.

      " as operand in a statement
      LOOP AT connection->get_output(  ) INTO DATA(line).

      ENDLOOP.

      "  to supply input parameter of another method
      out->write( data = connection->get_output( )
                  name = `  ` ).

    ENDIF.
Navigate to tab Local Typesand insert the following code snippet there:
Code Snippet

Copy code

Switch to dark mode

CLASS lcl_connection DEFINITION.
  PUBLIC SECTION.

* Attributes
    DATA carrier_id    TYPE /dmo/carrier_id.
    DATA connection_id TYPE /dmo/connection_id.

* Methods
    METHODS set_attributes
      IMPORTING
        i_carrier_id    TYPE /dmo/carrier_id  DEFAULT 'LH'
        i_Connection_id TYPE /dmo/connection_id.

    " Functional Method
    METHODS get_output
      RETURNING VALUE(r_output) TYPE string_table.

*  PROTECTED SECTION.

*  PRIVATE SECTION.

ENDCLASS.

CLASS lcl_connection IMPLEMENTATION.

  METHOD set_attributes.

    carrier_id    = i_carrier_id.
    connection_id = i_connection_id.

  ENDMETHOD.

  METHOD get_output.

    APPEND |------------------------------| TO r_output.
    APPEND |Carrier:     { carrier_id    }| TO r_output.
    APPEND |Connection:  { connection_id }| TO r_output.

  ENDMETHOD.

ENDCLASS.
Press CTRL + F3 to activate the class and F9 to execute it as a console app.
Analyze the console output. Debug the program, play around with the source code to get familiar with the concepts. In particular, debug the different calls of functional method get_output( )..
Define and Call Methods
In this exercise, you create and manage instances of your local class.

Template:
/LRN/CL_S4D400_CLS_INSTANCES (global Class)
Solution:
/LRN/CL_S4D400_CLS_METHODS (global Class)
Task 1: Copy Template (Optional)
Copy the template class. If you finished the previous exercise, you can skip this task and continue editing your class ZCL_##_LOCAL_CLASS or your class ZCL_##_INSTANCES.

Steps
Open the source code of global class/LRN/CL_S4D400_CLS_INSTANCES in the ABAP editor.

In the Eclipse toolbar, choose Open ABAP Development Object. Alternatively, press Ctrl + Shift + A.

Enter /LRN/CL_S4D400_CLS as search string.

From the list of development objects choose /LRN/CL_S4D400_CLS_INSTANCES, then choose OK.

Link the Project Explorer view with the editor.

In the Project Explorer toolbar, find the Link with Editor button. If it is not yet pressed, choose it. As a result, the development object, that is open in the editor, should be highlighted in the Project Explorer.

Copy class /LRN/CL_S4D400_CLS_INSTANCES to a class in your own package (suggested name: ZCL_##_METHODS, where ## stands for your group number).

In the Project Explorer view, right-click class /LRN/CL_S4D400_CLS_INSTANCES to open the content menu.

From the context menu, choose Duplicate ....

Enter the name of your package in the Package field. In the Name field, enter the name ZCL_##_METHODS, where ## stands for your group number.

Adjust the description and choose Next.

Confirm the transport request and choose Finish.

Task 2: Define Methods
In your local class lcl_connection, define instance methods get_output and set_attributes.

Steps
Navigate to the definition of the local class lcl_connection.

In the global class, choose Local Types.

Add a method get_output to the public section of the class. It should have one returning parameter r_outputof global table typeSTRING_TABLE.

Note

Remember to surround the name of the returning parameter with VALUE( ).
Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

 PUBLIC SECTION.

    DATA carrier_id    TYPE /dmo/carrier_id.
    DATA connection_id TYPE /DMO/Connection_id.

    CLASS-DATA conn_counter TYPE i.

    METHODS get_output
      returning
        value(r_output) type string_table.

  PROTECTED SECTION.
Note

For the moment, ignore the syntax error Implementation missing for method "GET_OUTPUT".
Add a method set_attributes to the public section of the class. It should have one importing parameter for each instance attribute of the class. Use the same types for the parameters that you used to type the attributes. To distinguish the parameters from the attributes, add prefix i_ to the parameter names. In addition, the method should raise exception CX_ABAP_INVALID_VALUE.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

PUBLIC SECTION.

    DATA carrier_id    TYPE /dmo/carrier_id.
    DATA connection_id TYPE /DMO/Connection_id.

    CLASS-DATA conn_counter TYPE i.

    METHODS set_attributes
      IMPORTING
        i_carrier_id    TYPE /dmo/carrier_id
        i_connection_id TYPE /dmo/connection_id
      RAISING
        cx_abap_invalid_value.

    METHODS get_output
      returning
        value(r_output) type string_table.

  PROTECTED SECTION.
Note

For the moment, ignore the syntax error Implementation missing for method "SET_ATTRIBUTES".
Task 3: Implement Methods
Steps
Use a quick fix to add the method implementations to the class.

Position the cursor on the name of one of the methods in the editor and press Ctrl + 1.

Double-click the suggestion Add 2 unimplemented methods.

Implement the method get_output. Append some string templates to returning parameter r_output. In the string templates, use embedded expressions to add the values of attributes carrier_id and connection_id.

In the local class add the following code between the statements METHOD get_output. and ENDMETHOD.

Code Snippet

Copy code

Switch to dark mode

     APPEND |------------------------------| TO r_output.
     APPEND |Carrier:     { carrier_id    }| TO r_output.
     APPEND |Connection:  { connection_id }| TO r_output.
Implement the method set_attributes. If either of the two importing parameters is empty (IS INITIAL), raise exception CX_ABAP_INVALID_VALUE. Otherwise, fill the two instance attributes with the values of the importing parameters.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

METHOD set_attributes.

  IF i_carrier_id IS INITIAL OR i_connection_id IS INITIAL.
    RAISE EXCEPTION TYPE cx_abap_invalid_value.
  ENDIF.

  carrier_id    = i_carrier_id. 
  connection_id = i_connection_id.

ENDMETHOD. 
Activate your class.

Choose Ctrl + F3 to activate the class.

Task 4: Call a Functional Method
In the main method of your global class, call the functional method get_output.

Steps
Switch to the implementation of method if_oo_adt_classrun~main in the global class.

In the global class, choose Global Class scroll down to the implementation of method if_oo_adt_classrun~main.

At the end of the method, add a loop over the internal table connections with reference variable connection as a work area.

Add the following code before ENDMETHOD..

Code Snippet

Copy code

Switch to dark mode

   LOOP AT connections INTO connection.

   ENDLOOP.
In the loop, call functional method get_output for each instance in turn and write the result to the console.

Hint

You can use the call of method get_output directly as input for out->write( ).
Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

  LOOP AT connections INTO connection.

     out->write( connection->get_output( ) ).

   ENDLOOP.
Activate the class. Execute it as a console app and analyze the console output.

Press Ctrl + F3 to activate the class.

Press F9 to run the class.

Analyze the output on the Console window.

Task 5: Use Code Completion and Handle Exceptions
Use code completion to call the method set_attributes and handle the exception the method raises.

Steps
For the first instance of class lcl_connection, replace the direct access to attributes carrier_id and connection_id with a call of the instance method set_attributes( ). Use code completion to insert the full signature of the method.

Hint

Press Ctrl + Space after you typed the component select (->) to display a list of available attributes and methods. Choose the method and then press Shift + Enter to insert the full signature of the method.
Place the cursor in the next line after the first connection = NEW #( )..

Type connection-> and press Ctrl + Space.

Choose set_attributes and press Shift + Enter.

Pass values to the importing parameters. Use the same literals that you used previously to set the attributes of this instance.

Remove or comment the direct access to the instance attributes for this instance.

Handle the exception. Surround the method call with TRY. and ENDTRY.. Add a CATCH-Block to handle exception CX_ABAP_INVALID_VALUE. Make sure the new instance is only added to internal table connections if the method call was successful.

Uncomment the generated code line CATCH cx_abap_invalid_value. .

Add TRY. before the method call .

Add ENDTRY. after the CATCH statement.

Between the CATCH statement and the ENDTRY statement add out->write( `Method call failed` ).

Move the APPEND statement up to between the method call and CATCH statement.

The complete method call should now look like this:

Code Snippet

Copy code

Switch to dark mode

    TRY.
        connection->set_attributes(
          EXPORTING
            i_carrier_id    = 'LH'
            i_connection_id = '0400'
        ).

*       connection->carrier_id    = 'LH'.
*       connection->connection_id = '0400'. 

        APPEND connection TO connections.

      CATCH cx_abap_invalid_value.
        out->write( `Method call failed` ).
    ENDTRY.
Repeat the previous step for the other two instances of class lcl_connection.

After this step, the implementation of method if_oo_adt_classrun~main should look similar to this:

Code Snippet

Copy code

Switch to dark mode

METHOD if_oo_adt_classrun~main.

    DATA connection TYPE REF TO lcl_connection.
    DATA connections TYPE TABLE OF REF TO lcl_connection.

* First Instance
**********************************************************************
    connection = NEW #(  ).

    TRY.
        connection->set_attributes(
          EXPORTING
            i_carrier_id    = 'LH'
            i_connection_id = '0400'
        ).

*        connection->carrier_id    = 'LH'.
*        connection->connection_id = '0400'.

        APPEND connection TO connections.

      CATCH cx_abap_invalid_value.
        out->write( `Method call failed` ).
    ENDTRY.

* Second instance
**********************************************************************

    connection = NEW #(  ).

    TRY.
        connection->set_attributes(
          EXPORTING
            i_carrier_id    = 'AA'
            i_connection_id = '0017'
        ).

*        connection->carrier_id    = 'AA'.
*        connection->connection_id = '0017'.

        APPEND connection TO connections.

      CATCH cx_abap_invalid_value.
        out->write( `Method call failed` ).
    ENDTRY.

* Third instance
**********************************************************************
    connection = NEW #(  ).

    TRY.
        connection->set_attributes(
          EXPORTING
            i_carrier_id    = 'SQ'
            i_connection_id = '0001'
        ).

*        connection->carrier_id    = 'SQ'.
*        connection->connection_id = '0001'.

        APPEND connection TO connections.

      CATCH cx_abap_invalid_value.
        out->write( `Method call failed` ).
    ENDTRY.


* Output
**********************************************************************

    LOOP AT connections INTO connection.

      out->write( connection->get_output( ) ).

    ENDLOOP.

  ENDMETHOD.
Activate the class. Execute it and debug the method calls.

Press Ctrl + F3 to activate the class.

Press F9 to run the class.

Using Encapsulation to Ensure Consistency
Objectives

After completing this lesson, you will be able to:
Explain encapsulation.
Define and use constructors.
Data Encapsulation

In object-oriented programming, an object corresponds to a real-life object such as an employee, a vehicle, or, in our case, a flight connection. It has attributes that describe it, in the case of a flight connection, those are the carrier id and the flight number.

Now let us consider what happens when a program that is using this object wants to provide values for these attributes. It is obvious that only those combinations of carrier id and flight number should be accepted that correspond to a flight connection in the real world.

In object orientation, the client program should not be able to change the attribute values directly. Instead, it should need to call a method to perform this task. The method, which comes with the object, can then check whether the combination of carrier id and flight number is valid and, if this is not the case - reject the change.

As developers of class lcl_connection, we can ensure the use of method set_attributes( ) by making attributes carrier_id and connection_id private, or at least read only.

This concept is called data encapsulation; The information about the flight connection is managed by the connection object itself and cannot be manipulated by anyone else. This ensures that no other point in the program can bypass the check of the consistency - either knowingly or unknowingly. This is one of the major advantages of object-orientation.

In object oriented programming, it is recommended to use data encapsulation as much as possible!

With the public attributes we defined by now, it was possible to read and change the values of the attributes anywhere inside and outside the class.

In order to restrict access to the attributes you have two options:

Keep the DATA statement or CLASS-DATA statement in the public section and add addition READ-ONLY. In doing so, write access to the attribute is forbidden outside of the class, but read access is still possible.
Note

Addition READ-ONLY is only allowed in the public section of a class.
Move the DATA statement or CLASS-DATA statement from the public section to one of the other visibility sections, for example the private section. In doing so, read access and write access to the attribute is forbidden outside of the class.
Hint

ADT offers a quick fix to change the visibility of an attribute. To use it place the cursor in the attribute name, press Ctrl + 1, and choose Make <attribute> private.
How To Use Private Attributes
Demo
Start Demo
Instance Constructor

By making your attributes private - or read-only, at least - you can ensure that the client program uses the available set_attributes( ) method to set the values for attributes carrier_id and connection_id.

But there is still potential for inconsistencies:

You cannot force the program to call set_attributes( ) for each new instance. As a result, there can be instances with initial values for carrier_id and connection_id.
The client program can call set_attributes( ) several times for the same instance. This should also not be possible.
What you need is a technique to enforce non-initial values during instantiation and to prevent later changes.

To solve these problems, object-oriented programming languages use constructor methods.


The runtime system calls the constructor automatically when you create a new instance of the class, but you may not call it explicitly. Thus the constructor is guaranteed to run once and once only for each instance that you create.

From a syntax perspective a constructor method has following properties:

a public instance method with the reserved name constructor
may have importing parameters, for example to obtain starting values for the attributes of the new instance
may raise exceptions
Note

In ABAP, it is not possible to define more than one constructor method in the same class.

Hint

In ADT, you can use a quick fix to generate a constructor method. To use this quick fix proceed as follows:

Either in the definition or implementation part, place the cursor in the class name and press Ctrl + 1.
From the list of available quick fixes, choose Generate constructor
On the dialog window that appears, select the attributes you want to initialize with the constructor and choose Finish
Once you generated the constructor you can adjust its definition and implementation to your needs.


The example shows the constructor of class lcl_connection. The generated definition contains an importing parameter for each of the attributes carrier_id and connection_id. The generated parameters have the same names as the related attributes.

The generated part of the implementation contains a value assignment for each of the attributes with the related importing parameter on the right. Self-reference me-> is needed to distinguish the attributes from the parameters of identical name.


The example shows some manual additions to the generated constructor of class lcl_connection.

In order to reject the creation of instances with initial values, a consistency check was added to the implementation and a RAISING clause to the definition of the constructor.

Because the constructor is executed once and only once for each new instance of class lcl_connection, the constructor implementation is the perfect place to increment static attribute conn_counter.


When you instantiate a class that has a constructor, the system calls the constructor method automatically. If the constructor has importing parameters, you pass them in the NEW expression exactly as you would pass parameters to a normal method.

Note

A constructor can have only importing parameters. Keyword EXPORTING is neither needed nor allowed in the NEW expression.
If the constructor has exceptions, you must ensure that you catch them by enclosing the instantiation in a TRY… CATCH...ENDTRY block. If an constructor raises an exception, control returns immediately to the program containing the NEW expression. In this case, you do not receive a new instance of the class.
How To Define An Instance Constructor
Demo
Start Demo
Static Constructor

While the instance constructor is called once when each instance of a class is created, you will sometimes need to perform actions once only for the entire class. For this purpose ABAP allows you to define a static constructor, also known as class constructor.

The runtime system calls the static constructor once only when the class is addressed for the first time during the execution of a program.

The first addressing of a class could be one of the following:

First instantiation of the class
First call of a static method
First access to a public static attribute
Note

This list is not complete. There are other actions (related to inheritance) that can cause a class to be addressed for the first time.
A typical use case for the static constructor is the dynamic initialization of static attributes with non-initial values. Therefore it is important that the runtime calls the static constructor before creating the instance, calling the static method, or addressing the static attribute.

From a syntax perspective a constructor method has following properties:

A public static method with the reserved name class_constructor
Without parameters or exceptions
Note

A static constructor must not have a signature because it is impossible to tell exactly when a class will be addressed for the first time.
Hint

In ADT, you can use a quick fix to generate a class constructor method. To use this quick fix proceed as follows:

Either in the definition or implementation part, place the cursor in the class name and press Ctrl + 1.
From the list of available quick fixes, choose Generate class constructor
How To Debug The Execution Of Constructors
Demo
Start Demo
Use Private Attributes and a Constructor
In this exercise, you make the the static attribute of your class read-only and the instance attributes private. You use a constructor to set their values.

Template:
/LRN/CL_S4D400_CLS_METHODS (global Class)
Solution:
/LRN/CL_S4D400_CLS_CONSTRUCTOR (global Class)
Task 1: Copy Template (Optional)
Copy the template class. If you finished the previous exercise, you can skip this task and continue editing your class (ZCL_##_METHODS, ZCL_##_LOCAL_CLASS or ZCL_##_INSTANCES).

Steps
Copy class /LRN/CL_S4D400_CLS_METHODS to a class in your own package (suggested name: ZCL_##_CONSTRUCTOR, where ## stands for your group number).

Open the source code of the global class /LRN/CL_S4D400_CLS_METHODS.

Link the Project Explorer view with the editor.

In the Project Explorer view, right-click the class /LRN/CL_S4D400_CLS_METHODS to open the context menu.

From the context menu, choose Duplicate ....

Enter the name of your package in the Package field. In the Name field, enter the name ZCL_##_CONSTRUCTOR, where ## stands for your group number.

Adjust the description and choose Next.

Confirm the transport request and choose Finish.

Task 2: Make Attributes Private
Change the visibility of the attributes carrier_id and connection_id to enforce the use of the methods set_attributes( ) and get_output( ).

Steps
Set the visibility of the attribute carrier_id to private using a quick fix.

Switch to the Local Types tab.

Go to the declaration of the attribute carrier_id in local class lcl_connection.

Place the cursor on carrier_id and press Ctrl + 1.

Double-click the suggestion Make carrier_id private.

Check that the declaration of the attribute carrier_id has moved to the private section.

Set the visibility of the attribute connection_id to private using a quick fix.

Go to the declaration of the attribute connection_id in the local class lcl_connection.

Place the cursor on connection_id and press Ctrl + 1.

Double-click the suggestion Make connection_id private.

Check that the declaration of attribute connection_id has moved to the private section.

Task 3: Create Instance Constructor
Replace the public method set_attributes with an instance constructor to ensure that the attributes are set during the creation of a new instance and that they are not changed afterward.

Steps
Comment out the definition and implementation of the method set_attributes.

Select all lines that belong to the METHODS set_attributes statement, including the line with the period sign (.).

Press Ctrl + < to add a star sign (*) in front of each selected line.

Select all lines that belong to the implementation of the method set_attributes including the corresponding ENDMETHOD. statement and press Ctrl + < again.

Add an instance constructor to the local class lcl_connection using a quick fix. Ensure that the constructor has importing parameters corresponding to attributes carrier_id and connection_id.

Place the cursor on the name of the class and press Ctrl + 1.

Double-click on Generate constructor.

In the dialog box, ensure that carrier_id and connection_id are selected and choose Finish.

Extend the generated constructor definition. Add exception CX_ABAP_INVALID_VALUE to the definition of the method constructor.

Navigate to the generated definition of the method constructor.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

METHODS constructor
      IMPORTING
        i_connection_id TYPE /dmo/connection_id
        i_carrier_id    TYPE /dmo/carrier_id
      RAISING
        cx_ABAP_INVALID_VALUE.
Extend the generated constructor implementation. If either of the importing parameters is initial, raise exception CX_ABAP_INVALID_VALUE.

Navigate from the definition to the implementation of the method constructor, for example, by placing the cursor on constructor and pressing F3.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

METHOD constructor.
 
    IF i_carrier_id IS INITIAL OR i_connection_id IS INITIAL.
      RAISE EXCEPTION TYPE cx_abap_invalid_value.
    ENDIF.

    me->connection_id = i_connection_id.
    me->carrier_id    = i_carrier_id.

  ENDMETHOD.
In the constructor implementation, add a statement to increase the value of the static attribute conn_counter by one. Make sure the statement is only executed if no exception was raised.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

    me->connection_id = i_connection_id.
    me->carrier_id    = i_carrier_id.
   
    conn_counter = conn_counter + 1.

  ENDMETHOD.
Make sure that it is not possible to change the value of conn_counter from outside the class.

Add READ-ONLY to the declaration of the static attribute conn_counter.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

   CLASS-DATA conn_counter TYPE i READ-ONLY.
Task 4: Use the Constructor
Adjust the instantiation of class lcl_connection to supply the parameters of the instance constructor and handle the exception.

Steps
In method if_oo_adt_classrun~main, go to the NEW #( ) expression for the first instance of lcl_connection.

Switch to the Global Class tab.

Find the first line with connection = NEW #( )..

In the NEW expression, supply the import parameters of constructor.

Hint

You can copy the parameter passing from the call of method set_attributes for this instance.
Adjust the NEW expression as follows:

Code Snippet

Copy code

Switch to dark mode

   connection = NEW #( 
                       i_carrier_id    = 'LH'
                       i_connection_id = '0400' 
                     ).
Remove or comment out all calls of the method set_attributes.

Select all lines that belong to the connection->set_attributes( ... ). statement, including the line with the closing bracket and the period sign (.).

Press Ctrl + < to add a star sign (*) in front of each selected line.

Move the instance creation into the TRY block of the exception handling.

Move the TRY. statement up, to before the instance creation.

Your first instance creation should now look like this:

Code Snippet

Copy code

Switch to dark mode

TRY.
    connection = NEW #( 
                        i_carrier_id    = 'LH'
                        i_connection_id = '0400'
                      ).
   
*        connection->set_attributes(
*          EXPORTING
*            i_carrier_id    = 'LH'
*            i_connection_id = '0400'
*        ).

        APPEND connection TO connections.

      CATCH cx_abap_invalid_value.
        out->write( `Method call failed` ).
    ENDTRY.
Repeat the previous steps for the other instances of your local class.

After this step, the implementation of the method if_oo_adt_classrun~main should look similar to this:

Code Snippet

Copy code

Switch to dark mode

METHOD if_oo_adt_classrun~main.

    DATA connection TYPE REF TO lcl_connection.
    DATA connections TYPE TABLE OF REF TO lcl_connection.

* First Instance
**********************************************************************
    TRY.
    connection = NEW #( 
                        i_carrier_id    = 'LH'
                        i_connection_id = '0400'
                      ).
   
*        connection->set_attributes(
*          EXPORTING
*            i_carrier_id    = 'LH'
*            i_connection_id = '0400'
*        ).

        APPEND connection TO connections.

      CATCH cx_abap_invalid_value.
        out->write( `Method call failed` ).
    ENDTRY.

* Second instance
**********************************************************************
    TRY.
    connection = NEW #(  
                        i_carrier_id    = 'AA'
                        i_connection_id = '0017'
                      ).
        APPEND connection TO connections.

      CATCH cx_abap_invalid_value.
        out->write( `Method call failed` ).
    ENDTRY.

* Third instance
**********************************************************************
    TRY.
    connection = NEW #(  
                        i_carrier_id    = 'SQ'
                        i_connection_id = '0001'
                      ).
        APPEND connection TO connections.

      CATCH cx_abap_invalid_value.
        out->write( `Method call failed` ).
    ENDTRY.

* Output
**********************************************************************
    LOOP AT connections INTO connection.
      out->write( connection->get_output( ) ).
    ENDLOOP.
  ENDMETHOD.
Activate the class. Execute it and debug the instantiation.

Press Ctrl + F3 to activate the class.

Press F9 to run the class.

Investigating a Table Definition
Objective

After completing this lesson, you will be able to investigate a table definition.
Database Table Definitions
Every ABAP system runs on a relational database management system (DBMS). Originally, ABAP supported different database management systems from different vendors. Therefore the definition of database objects like tables and views is done in a database independent way.

Note

Newer ABAP releases only support SAP HANA as database. The ABAP Environment on SAP BTP always runs on SAP HANA.


In a relational database, information is stored in two-dimensional tables, in which each row represents one data record whose contents are split up into columns. The database is called a relational database, as there are also relations between tables. For example, the table in the figure contains an airline code. In the database table, there would be a relationship to a further table containing the information that AA stands for American Airlines, JL for Japanese Airline, LH for Lufthansa, and so on.

A sequence of columns at the beginning of each database table forms its key. The key is a combination of values that ensures that each row in the table can be identified uniquely.

In SAP systems, database table definitions are development objects, and as such, are cross-client. However, the vast majority of tables contain business data, which is client-specific. To keep the data separate, client-specific tables have a client field (often named CLIENT or MANDT) as their first key field. The database of SAP accesses statements using ABAP SQL to ensure that a statement only manipulates data from the current client.

Database Table Definitions
ADT provides a dedicated editor for database table definitions.

Let's look at the different parts of the table definition.

Data Preview for Database Tables
You can use the Data Preview tool to display and analyze the content of a database table. To open the Data Preview for a given table, right-click anywhere in the table definition and choose Open With→Data Preview. Alternatively, place the cursor anywhere in the database table definition and press F8.

The tool displays the data stored in the database table. Watch the video to learn about some of the most important functions.

How to Analyze a Database Table

Implementing Basic SELECT Statements
Objectives

After completing this lesson, you will be able to:
Describe basic features of ABAP SQL.
Read single values from the database.
Basic ABAP SQL Syntax
Structured Query Language (SQL)

All relational database systems use a variant of Structured Query Language (SQL) to allow you to work with them. Standard SQL consists of three main components:

Data Manipulation Language (DML)
DML comprises of the statements that you need to work with information in database tables. These are INSERT, for adding new records, SELECT, for reading data, UPDATE, to change existing records, and DELETE, to delete table contents. These statements are reflected in ABAP in the form of ABAP SQL.
Data Definition Language (DDL)
Data Definition Language provides you with commands that enable you to create and delete database tables and other database artifacts such as schemata, table indexes, and views. In an SAP system, you perform these tasks using dedicated editors of ADT, not with ABAP programs. One example is the editor for database table definitions we saw earlier.
Data Control Language (DCL)
Data Control Language is used in SQL to restrict access to data in the database for a particular user. It is not used in its classic form in ABAP, since the users at database level do not correspond one-to-one with the end users. Consequently, ABAP has its own authorization concept.
ABAP SQL Architecture

In the past, SAP systems had to support a range of database platforms, and each platform had a slightly different implementation of the SQL standard. This meant that each platform needed slightly different commands to achieve a particular task. To avoid the ABAP code being database-specific, SAP invented ABAP SQL - or Open SQL as it was called originally.

Note

The name change from Open SQL and ABAP SQL also illustrates that as off release 7.53 ABAP only supports SAP HANA as DBMS.
ABAP SQL is an abstract set of SQL commands implemented at ABAP level and integrated into the ABAP language. At runtime, ABAP SQL is translated into a variant of SQL that the database understands. This variant is called Native SQL to distinguish it from ABAP SQL, the SQL variant that is integrated into ABAP. The translation from ABAP SQL to Native SQL takes place in the database interface, a component of the ABAP system that consists of a general part and a database-specific library.

Even though newer ABAP releases only support SAP HANA as DBMS, SAP has still retained the concept of ABAP SQL and the database interface. This is because of the following reasons:

Architecture compatibility
ABAP SQL and the database interface are an integral part of the system architecture.
Code compatibility
ABAP SQL coding from previous SAP products (including customer-specific development) should run free of side-effects in the modern, SAP-HANA-only ABAP environments.
Tasks of the Database Interface
The database interface does not just translate statements; it is also responsible for ABAP specific tasks like, for example, automatic client-handling.
Single Record Reading from the Database
The SELECT Statement in ABAP

To read data from the database, you use the SELECT statement.

When you write a SELECT statement in ABAP SQL, the syntax check compares what you have written with the definition of the tables and views. If you try to address tables, views, or fields that do not exist, a syntax error occurs.

The basic syntax of the SELECT statement contains several sections, called clauses, and always follows the pattern in the figure, The SELECT Statement in ABAP. The most important clauses of a SELECT statement are as follows:

FROM
In the FROM clause of the SELECT statement, you specify the data source from which you want to read. This can be either be a database table or a view. Special SQL techniques allow you to combine data from multiple sources in the same SELECT statement.
FIELDS
In the FIELDS clause of the SELECT statement, you list the columns of the database table that you want to read. The columns in the list must be separated by commas. If you want to read the entire table line, you can specify FIELDS * instead of a column list. Be aware, however, that this can cause the database considerably more work than just reading the columns you need.
WHERE
In the WHERE clause, you can specify a condition that describes which rows of the table will be read. For example, the condition WHERE carrier_id = 'LH' means that only those rows will be read (in which the column CARRIER_D contains the value LH).

The WHERE clause can contain multiple conditions linked with the AND and OR operators. For example, WHERE carrier_id = 'LH' and connection_id = '0400' would return the data of flight connection LH 0400. You can also negate conditions using NOT. The WHERE clause is the only clause that is optional. Be aware, however, that without a WHERE clause you read all data from the table, or if the table has a client field - all data that belongs to the logon client of the user. SELECTs without a WHERE clause can cause serious performance problems and should be avoided.

INTO
The INTO clause specifies the variable or variables in the ABAP program into which the data should be placed. This is normally a structure, or an internal table, and should ideally have the same sequence of components as the column list in the FIELDS clause.
Note

You will see other forms of SQL syntax in ABAP. These are older and have been retained to ensure compatibility. You should get used to using the modern syntax, as it provides far more functions and features than the old form.

The figure, Example 1: Reading Single Field of Single Record, illustrates a SELECT statement that reads a single value from the database. The FROM clause tells us that the statement reads from database table /DMO/CONNECTION. The option, SINGLE, after the keyword, SELECT, indicates that only one row (a single record) is read. This row is identified in the WHERE clause by providing key filter values for key fields carrier_id and connection_id. Keep in mind, that the database interface will add a filter on the remaining key field client.

The FIELDS clause lists only one column of the table: column AIRPORT_FROM_ID.

The INTO clause has to match the rest of the statement. In our example, this specifies the variable airport_from_id as the target object, a scalar data object of identical type as table field, airport_from_id.

Note

The at sign (@) identifies airport_from_id as the name of an ABAP data object. It is mandatory for all variables and constants that you use in an ABAP SQL statement. It is needed to avoid ambiguities if, for example, a data object and table field have the same name.

The figure, Example 2: Reading Several Fields of Single Record, illustrates a SELECT statement that reads two values from the same record of the database.

This time, the FIELDS clause lists two columns of the table; column AIRPORT_FROM_ID and column AIRPORT_TO_ID.

To match this, the INTO clause specifies the variables airport_from_id and airport_to_id as the target objects. They are separated by a comma and surrounded by pair of brackets to make it clear that together they form the target of the SELECT statement.


When you implement a SELECT statement you always have to take into account that there could be no result, either because the database table does not contain any data at all or because it does not contain any rows that fulfill the conditions in the WHERE clause. In the example from the figure above, the database table does not contain a row with carrier_id = 'XX' and connection_id = '1234'.

ABAP SQL use system field SY-SUBRC to indicate a successful or unsuccessful execution of a statement. System field SY-SUBRC is of type integer. Initial value 0 always indicates a successful execution. If, after a SELECT statement, SY-SUBRC contains the value 4, this indicates that the database returned an empty result.

If the database returns an empty result, ABAP SQL does NOT touch the target variable after INTO!

In particular, the target variable is not initialized in case of an error.


It is recommended that you evaluate the content of system field sy-subrc immediately after each SELECT statement.

Try It Out: SELECT Examples
Like in the first exercise of this course, create a new global class that implements interface IF_OO_ADT_CLASSRUN.
Copy the following code snippet to the implementation part of method if_oo_adt_classrun~main( ):
Code Snippet

Copy code

Switch to dark mode

    DATA airport_from_id TYPE /DMO/airport_from_id.
    DATA airport_to_id   TYPE /DMO/airport_to_id.

    DATA airports TYPE TABLE OF /DMO/airport_from_id.

* Example 1: Single field from Single Record
**********************************************************************
    SELECT SINGLE
      FROM /dmo/connection
      FIELDS airport_from_id
      WHERE carrier_id    = 'LH'
        AND connection_id = '0400'
        INTO @airport_from_id.

    out->write( `----------`  ).
    out->write( `Example 1:`  ).

    out->write( |Flight LH 400 departs from {  airport_from_id }.| ).

* Example 2: Multiple Fields from Single Record
**********************************************************************
    SELECT SINGLE
      FROM /dmo/connection
      FIELDS airport_from_id, airport_to_id
      WHERE carrier_id    = 'LH'
        AND connection_id = '0400'
        INTO (  @airport_from_id, @airport_to_id ).

    out->write( `----------`  ).
    out->write( `Example 2:`  ).

    out->write( |Flight LH 400 flies from {  airport_from_id } to { airport_to_id  }| ).

* Example 3: Empty Result and sy-subrc
**********************************************************************
    SELECT SINGLE
      FROM /dmo/connection
      FIELDS airport_from_id
      WHERE carrier_id    = 'XX'
        AND connection_id = '1234'
        INTO @airport_from_id.

    IF sy-subrc = 0.

      out->write( `----------`  ).
      out->write( `Example 3:`  ).
      out->write( |Flight XX 1234 departs from {  airport_from_id }.| ).

    ELSE.

      out->write( `----------`  ).
      out->write( `Example 3:`  ).
      out->write( |There is no flight XX 1234, but still airport_from_id = {  airport_from_id }!| ).

    ENDIF.
Press CTRL + F3 to activate the class and F9 to execute it as a console app.
Analyze the console output. Debug the program, play around with the source code to get familiar with the concepts.
Read Data from a Database Table
In this exercise, you extend your local class with attributes for the departure airport and the destination airport, and read the values for these attributes from a database table.

Template:
/LRN/CL_S4D400_CLS_CONSTRUCTOR (global Class)
Solution:
/LRN/CL_S4D400_DBS_SELECT (global Class)
Task 1: Copy Template
Copy the template class. Alternatively, copy your solution of the previous exercise.

Steps
Copy the class /LRN/CL_S4D400_CLS_CONSTRUCTOR to a class in your own package (suggested name: ZCL_##_SELECT, where ## stands for your group number).

Open the source code of the global class /LRN/CL_S4D400_CLS_CONSTRUCTOR.

Link the Project Explorer view with the editor.

In the Project Explorer view, right-click class /LRN/CL_S4D400_CLS_CONSTRUCTOR to open the context menu.

From the context menu, choose Duplicate ....

Enter the name of your package in the Package field. In the Name field, enter the name ZCL_##_SELECT, where ## stands for your group number.

Adjust the description and choose Next.

Confirm the transport request and choose Finish.

Task 2: Declare Additional Attributes
Extend the local class lcl_connection with the private instance attributes airport_from_idand airport_to_id. Add some output for the new attributes to the implementation of the method get_output.

Note

The new attributes are not filled yet. In order to fill them we will add a SELECT statement to the constructor in one of the next tasks of this exercise.
Steps
Switch to the local class lcl_connection.

In the global class, choose Local Types.

Add the following private attributes to the class definition:

Attributes
Attribute Name	Scope	Data Type
airport_from_id	instance	/DMO/AIRPORT_FROM_ID
airport_to_id	instance	/DMO/AIRPORT_TO_ID
Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

  PRIVATE SECTION.
    DATA carrier_id    TYPE /dmo/carrier_id.
    DATA connection_id TYPE /dmo/connection_id.

    DATA airport_from_id TYPE /dmo/airport_from_id.
    DATA airport_to_id   TYPE /dmo/airport_to_id.

ENDCLASS.
Extend the implementation of the method get_output. Append more string templates to the returning parameter r_output. Embed the new attributes as expressions into the string templates.

Navigate to the implementation of the method get_output.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

    APPEND |--------------------------------|             TO r_output.
    APPEND |Carrier:     { carrier_id      }|             TO r_output.
    APPEND |Connection:  { connection_id   }|             TO r_output.
    APPEND |Departure:   { airport_from_id }|             TO r_output.
    APPEND |Destination: { airport_to_id   }|             TO r_output.
Activate the class. Execute it and analyze the console output.

Press Ctrl + F3 to activate the class.

Press F9 to run the class.

Task 3: Analyze the Database Table
Analyze the definition of the database table /DMO/CONNECTION.

Steps
Open the development object that contains the definition of the database table /DMO/CONNECTION.

From the eclipse toolbar, choose Open ABAP Development Object or press Ctrl + Shift + A.

In the input field, enter /dmo/con as a search string.

In the list of matching items, click on /DMO/CONNECTION (Database Table) and choose OK.

Open the Tooltip Description for the database table /DMO/CONNECTION.

Click on /dmo/connection after the keyword define table and press F2 to show the tooltip description.

Task 4: Read Data from the Database
In the method constructor of the local class lcl_connection, implement a SELECT statement that reads values for the new attributes from the database table /DMO/CONNECTION.

Steps
Return to the local class lcl_connection in your global class.

In the editor view of Eclipse, open tab ZCL_##_SELECT.

In the global class, choose Local Types.

Navigate to the implementation of the method constructor.

Search for the code line METHOD constructor..

After the ENDIF. statement, add a SELECT statement that reads a single record from database table /DMO/CONNECTION.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

  IF i_carrier_id IS INITIAL OR i_connection_id IS INITIAL.
    RAISE EXCEPTION TYPE cx_abap_invalid_value.
  ENDIF.

  SELECT SINGLE
    FROM /dmo/connection

Implement the FIELDS clause. Read the table fields airport_from_id and airport_to_id.

Hint

Use auto-completion (Ctrl + Space) to enter the field names.
After FROM /DMO/CONNECTION enter FIELDS.

After a blank, press Ctrl + Space and choose airport_from_id.

After a comma and a blank press Ctrl + Space again and choose airport_to_id.

The complete FIELDS clause should look like this:

Code Snippet

Copy code

Switch to dark mode

      FIELDS DepartureAirport, DestinationAirport
Implement the WHERE condition. Restrict all key fields of the database table (except for the client field) with the values of importing parameters i_carrier_id and i_connection_id. Do not forget to escape the parameters with prefix @.

Hint

Use auto-completion (Ctrl + Space) to enter the element names and parameter names.
Add the following code after the FIELDS clause:

Code Snippet

Copy code

Switch to dark mode

     WHERE carrier_id    = @i_carrier_id
       AND connection_id = @i_connection_id
Implement the INTO clause. Store the SELECT result in the attributes airport_from_id, and airport_to_id. Do not forget to escape the attributes with prefix @.

Hint

Use auto-completion (Ctrl + Space) to enter the attribute names.
Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

 
    WHERE carrier_id    = @i_carrier_id
      AND connection_id = @i_connection_id   
    INTO ( @airport_from_id, @airport_to_id ).
The complete SELECT statement should look like this:

Code Snippet

Copy code

Switch to dark mode

SELECT SINGLE
      FROM /dmo/connection
    FIELDS airport_from_id, airport_to_id
     WHERE carrier_id    = @i_carrier_id
       AND connection_id = @i_connection_id
      INTO ( @airport_from_id, @airport_to_id ).
Implement error handling after the SELECT statement. Check the content of the system field sy-subrc. If it does not equal zero, raise exception CX_ABAP_INVALID_VALUE.

Add the following code after the SELECT statement:

Code Snippet

Copy code

Switch to dark mode

   IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE cx_abap_invalid_value.
   ENDIF.
Activate the class. Execute it and analyze the console output. Check that the output for the new attributes displays data.

Press Ctrl + F3 to activate the class.

Press F9 to run the class.

Working with CDS View
Objectives

After completing this lesson, you will be able to:
Analyze a CDS view definition.
Read data using a CDS view.
CDS Views
View Definitions in ABAP Core Data Services (ABAP CDS)
ABAP Core Data Services, or ABAP CDS for short, is an infrastructure for defining and consuming semantically rich data models in ABAP. They use a CDS DDL to define CDS entities that implement a semantic data model. The most important CDS modeling entities are CDS View entities.


The CDS View definition contains re-usable SQL logic; sometimes as simple as a projection of table fields and sometimes more sophisticated with calculations, aggregations, joins, unions, and so on.

A CDS View definition can contain associations to reflect the relations of the data model. Consumers of the view can use the associations to retrieve related data.

Finally, annotations are used to semantically enrich the view definition. This metadata is evaluated by frameworks that build on top of CDS View definitions. One such framework is the ABAP RESTful application programming model , for which we will discuss an example later in this course.

Let's watch examples of CDS view definitions.


CDS View definitions are contained in repository objects of type Data Definition. Let us now have a look at the source code of data definition /DMO/I_CONNECTION.

The main part is the DEFINE VIEW ENTITY statement. It contains the name of the CDS View entity and, after keyword FROM, the data source. In our example, the name of the view entity is /DMO/I_Connection and the data source is database table /dmo/connection. Optional addition AS, defines an alias name Connection to address the data source inside the View definition.

Note

The source of a CDS View entity could also be another CDS View.
A pair of curly brackets contains the list of view elements. In our example, the view elements are fields of database table /dmo/connection. Keyword Key in front of the first two elements defines them as key fields of the CDS View entity. Optional addition AS defines an alias name for each view element.


Addition association defines a relation to another CDS view entity. In our example, the related is CDS view entity /DMO/I_Carrier and the name of the association is _Airline.

This association becomes available for consumers of the view by adding it to the element list. This is referred to as exposing the association.


Annotations start with the at sign (@) and they are used to semantically enrich the view definition for consumers. Annotations before the view definition are called entity annotations. Entity annotations are used to define metadata for the view entity as a whole. Annotations between the curly brackets are called element annotations. Element annotations are used to define metadata for the different elements of the view.


You already learned how to use the Data Preview tool to display and analyze the content of a database table. This tool is also available for CDS view entities.

To open the Data Preview for a given CDS entity, right-click anywhere in the data definition and choose Open With > Data Preview. Alternatively, place the cursor anywhere in the database table definition and press Ctrl + F8.

The tool displays the data returned by the CDS entity. The same functions are available to sort or filter the data and adjust the display.

If the view definition contains one or more associations, you can use them to display related data. To do so, proceed in the following manner:

Right-click on a row in the display.
From the context menu, choose Follow Association.
From the list of available associations, choose the one in which you are interested.

If you want to find all CDS Views with a certain database table as a source, you can utilize the Where-used List tool of ADT. To use this tool, proceed as follows:

Open the definition of the database table.
Right-click anywhere in the source code and choose Get Where-used List from the context menu. Alternatively, you can press Ctrl + Shift + G, or choose the button from the toolbar with the same symbol.
The Search view displays a list of all development objects that directly use the database table.

You can apply filters to the Where-used List if, for example, you are only interested in objects from certain packages or objects of the specific object type. The example illustrates how to filter for CDS views that use the table.

How to Analyze a CDS View
Demo
Start Demo
CDS Views in ABAP SQL

When you implement a SELECT statement in ABAP, you can use a CDS view entity as the data source instead of reading from the database table directly. This has several advantages.

Re-use of the SQL logic contained in the CDS view
Concise, easy-to-read reading of related data using the associations
Sometimes the names of views and view elements are better readable than the more technical names of database tables and table fields
The SELECT statement in the example uses CDS view entity /DMO/I_Connection as a data source.

Note

Note that the names used in the FIELDS clause and WHERE conditions are the alias names of the view elements.
The third element in the FIELDS clause makes use of exposed association _Airline. It reads element name from the associated CDS view entity /DMO/I_Airline. This kind of element is called a path expression. The backslash (\) is a mandatory prefix for association names.

Analyze and Use a CDS View Entity
In this exercise, you read from a CDS view entity rather than from the database table directly. This provides you with comfortable access to the name of the airline as well.

Template:
/LRN/CL_S4D400_DBS_SELECT (global Class)
Solution:
/LRN/CL_S4D400_DBS_CDS (global Class)
Task 1: Copy Template (Optional)
Copy the template class. If you finished the previous exercise, you can skip this task and continue editing your class ZCL_##_SELECT.

Steps
Copy the class /LRN/CL_S4D400_DBS_SELECT to a class in your own package (suggested name: ZCL_##_CDS, where ## stands for your group number).

Open the source code of the global class /LRN/CL_S4D400_DBS_SELECT.

Link the Project Explorer view with the editor.

In the Project Explorer view, right-click the class /LRN/CL_S4D400_DBS_SELECT to open the context menu.

From the context menu, choose Duplicate ....

Enter the name of your package in the Package field. In the Name field, enter the name ZCL_##_CDS, where ## stands for your group number.

Adjust the description and choose Next.

Confirm the transport request and choose Finish.

Task 2: Analyze CDS View Entity
Analyze the definition of the CDS view entity /DMO/I_Connection.

Steps
Open the development object that contains the definition of the CDS view entity /DMO/I_Connection.

From the eclipse toolbar, choose Open ABAP Development Object or press Ctrl + Shift + A.

In the input field, enter /DMO/I_Con as a search string.

In the list of matching items, click on /DMO/I_CONNECTION (Data Definition) and choose OK.

Analyze the element list of the CDS view entity.

Navigate to the comma-separated list between the pair of curly brackets ( { } ).

You find the alias names after keyword AS.

Open the Tooltip Description for the target of association _Airline.

Click on /DMO/I_Carrier beforeas _Airline and press F2 to show the tooltip description.

Task 3: Declare Additional Attribute
Extend the local class lcl_connection with a private instance attribute carrier_name. Add some output for the new attribute to the implementation of method get_output( ).

Note

The new attribute is not filled, yet. In order to fill it we will adjust the SELECT statement in the next task of this exercise.
Steps
Return to the local class lcl_connection in your global class.

In the global class, choose Local Types.

Add the following private attribute to the class definition:

Attributes
Attribute Name	Scope	Data Type
carrier_name	instance	/DMO/CARRIER_NAME
Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

  PRIVATE SECTION.
    DATA carrier_id      TYPE /dmo/carrier_id.
    DATA connection_id   TYPE /dmo/connection_id.

    DATA airport_from_id TYPE /dmo/airport_from_id.
    DATA airport_to_id   TYPE /dmo/airport_to_id.

    DATA carrier_name    TYPE /dmo/carrier_name.
ENDCLASS.
Extend the implementation of method get_output. Add the carrier name to the string template with the carrier identification.

Navigate to the implementation of method get_output.

Replace statement APPEND |Carrier:     { carrier_id      }| TO r_output. with the following statement:

Code Snippet

Copy code

Switch to dark mode

  APPEND |Carrier:     { carrier_id } { carrier_name }| TO r_output.
Activate the class. Execute it and analyze the console output.

Press Ctrl + F3 to activate the class.

Press F9 to run the class.

Task 4: Use CDS View Entity
In the implementation of method constructor, replace the SELECT statement that reads from database table /dmo/connection with a SELECT statement that reads from CDS view entity /DMO/I_Connection.

Steps
In the implementation of method constructor, comment the SELECT statement.

Select all lines that belong to the SELECT SINGLE ... ..

Press Ctrl + < to add a star sign (*) in front of each selected line.

After the commented code, add a SELECT statement that reads a single record from database table /DMO/I_Conncetion.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

*    SELECT SINGLE
*      FROM /dmo/connection
*    FIELDS airport_from_id, airport_to_id
*     WHERE carrier_id    = @i_carrier_id
*       AND connection_id = @i_connection_id
*      INTO ( @airport_from_id, @airport_to_id ).

  SELECT SINGLE
    FROM /DMO/I_Connection

Implement the FIELDS clause. Read view elements DepartureAirport and DestinationAirport. In addition, read view element Name from the target of association _Airline.

Hint

Use auto-completion (Ctrl + Space) to enter the names.
After FROM /DMO/I_Connection enter FIELDS.

After a blank, press Ctrl + Space and choose DepartureAirport.

After a comma and a blank press Ctrl + Space again and choose DestinationAirport.

After a comma and a blank, type in a backslash (\) , press Ctrl + Space and choose _Airline.

Immediately after _Airline, type in a dash sign (-) , press Ctrl + Space and choose Name.

The complete FIELDS clause should look like this:

Code Snippet

Copy code

Switch to dark mode

      FIELDS DepartureAirport, DestinationAirport, \_Airline-Name
Implement the WHERE condition. Restrict the key elements of CDS view entity with the values of importing parameters i_carrier_id and i_connection_id. Do not forget to escape the parameters with prefix @.

Hint

Use auto-completion (Ctrl + Space) to enter the element names and parameter names.
Add the following code after the FIELDS clause:

Code Snippet

Copy code

Switch to dark mode

     WHERE AirlineID    = @i_carrier_id
       AND ConnectionID = @i_connection_id
Implement the INTO clause. Store the SELECT result in attributes airport_from_id, airport_to_id, and airline_name. Do not forget to escape the attributes with prefix @.

Hint

Use auto-completion (Ctrl + Space) to enter the attribute names.
Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

     WHERE AirlineID    = @i_carrier_id
       AND ConnectionID = @i_connection_id
      INTO ( @airport_from_id, @airport_to_id, @carrier_name ).
The complete SELECT statement should look like this:

Code Snippet

Copy code

Switch to dark mode

SELECT SINGLE
      FROM /DMO/I_Connection
    FIELDS DepartureAirport, DestinationAirport, \_Airline-Name
     WHERE AirlineID    = @i_carrier_id
       AND ConnectionID = @i_connection_id
      INTO ( @airport_from_id, @airport_to_id, @carrier_name  ).
Activate the class. Execute it and analyze the console output. Check that the output for the new attributes displays data.

Press Ctrl + F3 to activate the class.

Press F9 to run the class.

Declaring a Structured Data Object
Objective

After completing this lesson, you will be able to declare a structured data object.
Structured Data Objects

Up until now, you have been using simple variables, each of which can store a single piece of information. Here, for example, there are two variables, one for the departure airport, the other for the arrival airport.

When you read a record from the database you need to hold all of this information together. The two variables in the example are completely independent of one another, and are therefore not suitable for storing different pieces of information that belong together.

In ABAP, the solution is to use a structured variable, or a structure, for short.


A structure is a variable ABAP data object with a name and a structured type.

In the example, data object connection_full is such a structure. It is subdivided into eight components, each of which also has a name and a type. You can address both the structure as a whole and the individual components. Importantly, you can use each component in exactly the same way that you would use a standalone simple variable.

There are various possibilities to declare a structure. You can define structured types with keyword TYPES or use a repository object of type Structure. The definitions of views and database tables can also serve as structured types. The example uses CDS View /DMO/I_Connection as a structured type.


In the debugger perspective, there are two ways to analyze the structure and content of a structured variable:

Variable Preview (Mouse Over)
Set the focus on the Source Code Editor and place the pointer on a variable name. After a moment a dialog window opens with details on the structure and content of the data object.

Display in the Variables View (Double-Click)
To display the variable in the Variables view, either enter the variable name under <enter variable> or double-click the variable name somewhere in the source code editor. Expand the node with the structure name to see the list of components

How To Analyze Structured Data Objects Using The Debug Perspective
Demo
Start Demo
Structured Data Types

A global structure type is a repository object that can be used as data type anywhere in the system. In the example, structured type SYMSG is used to declare variable message.

When you press the F2 key to display the details of this data type you can see that this is a structure type consisting of seven components. You can also see the names, technical types and descriptions of the components.

When you press the F3 key to navigate to the definition of the type, a new view opens with the ADT editor for global structured types.

The definition of a global structure type is very similar to the definition of a database table. The main part of the definition consists of a DEFINE STRUCTURE statement with the name of the structure type. This is followed by the list of structure components in a pair of curly brackets ( { , } ); each component with a component type. Component types are often described by data elements, but it is also possible to use structure types as component types. Structures with structured components are referred to as Nested Structures.

Additional code lines before the DEFINE STRUCTURE statement specify additional properties of the structure type, among them a label.


You can also define structured types in an ABAP program using the TYPES statement. The structure definition begins with the statement TYPES BEGIN OF <structure type name> and ends with TYPES END OF <structure type name>. In between, you name each component and specify its type in an additional TYPES statement.

A compact form uses keyword TYPES only once, followed by a colon( : ). The BEGIN OF addition, the END OF addition and the component definitions in between are then separated by commas.

This is referred to as chain statement.

Note

In the past, chain statements were used a lot in ABAP. Nowadays they are only recommended to combine statements that belong closely together.

In this example, a chain statement TYPES: is used to define local structured type st_connection which consists of the three components airport_from_id, airport_to_id, and carrier_name. Each component is typed with a data element beginning with /dmo/.

Local structured type st_connection is then used in a DATA statement to type structured variable connection.


In this example, variable connection has a nested structured type. Type st_nested defines 4 components. The first three are typed with data elements, therefore they are simple components. The fourth component message, however, is typed with a structured type. Therefore it is a structured component. This makes variable connection nested structure.


ABAP supports not only structured variables but also structured constants. To define a structured constant, use BEGIN OF and END OF as part of a CONSTANTS statement. The example shows a structured constant that is defined in the public section of global class CL_ABAP_BEHV. All four components are typed with data element SECKEYNAME. Remember that addition VALUE is mandatory when defining constants.

Try It Out: Structured Data Types
Like in the first exercise of this course, create a new global class that implements interface IF_OO_ADT_CLASSRUN.
Copy the following code snippet to the implementation part of method if_oo_adt_classrun~main( ):
Code Snippet

Copy code

Switch to dark mode

* Example 1 : Motivation for Structured Variables
**********************************************************************

    DATA connection_full TYPE /DMO/I_Connection.

    SELECT SINGLE
     FROM /dmo/I_Connection
   FIELDS AirlineID, ConnectionID, DepartureAirport, DestinationAirport,
          DepartureTime, ArrivalTime, Distance, DistanceUnit
    WHERE AirlineId    = 'LH'
      AND ConnectionId = '0400'
     INTO @connection_full.

    out->write(  `--------------------------------------` ).
    out->write(  `Example 1: CDS View as Structured Type` ).
    out->write( connection_full ).

* Example 2: Global Structured Type
**********************************************************************

    DATA message TYPE symsg.

    out->write(  `---------------------------------` ).
    out->write(  `Example 2: Global Structured Type` ).
    out->write( message ).

* Example 3 : Local Structured Type
**********************************************************************

    TYPES: BEGIN OF st_connection,
             airport_from_id TYPE /dmo/airport_from_id,
             airport_to_id   TYPE /dmo/airport_to_id,
             carrier_name    TYPE /dmo/carrier_name,
           END OF st_connection.

    DATA connection TYPE st_connection.

    SELECT SINGLE
      FROM /DMO/I_Connection
    FIELDS DepartureAirport, DestinationAirport, \_Airline-Name
     WHERE AirlineID = 'LH'
       AND ConnectionID = '0400'
      INTO @connection.

    out->write(  `---------------------------------------` ).
    out->write(  `Example 3: Local Structured Type` ).
    out->write( connection ).

* Example 4 : Nested Structured Type
**********************************************************************

    TYPES: BEGIN OF st_nested,
             airport_from_id TYPE /dmo/airport_from_id,
             airport_to_id   TYPE /dmo/airport_to_id,
             message         TYPE symsg,
             carrier_name    TYPE /dmo/carrier_name,
           END OF st_nested.

    DATA connection_nested TYPE st_nested.

    out->write(  `---------------------------------` ).
    out->write(  `Example 4: Nested Structured Type` ).
    out->write( connection_nested ).
Press CTRL + F3 to activate the class and F9 to execute the console app.
Analyze the console output. Debug the program, play around with the source code to get familiar with the concepts.

Working with Structured Data Objects
Objectives

After completing this lesson, you will be able to:
Work with structured data objects.
Use structured data objects in ABAP SQL.
Structured Data Objects

To access a component of a structure, you have to place a minus-sign (-) between the structure name and the component name.

Note

No blanks are allowed before or after the component selector.
Accessing a structure component that way, you can use it in any operand position in which you can use a variable of the same type. Component airport_from_id of structure connection in the example above is of type /DMO/AIRPORT_FROM_ID. In consequence, you can use this component in any operand position in which you could use a simple variable of type /DMO/AIRPORT_FROM_ID; not only on the left-hand side of a value assignment as in the example, but also on the right-hand side, in the parameter passing of a method call, in the INTO clause or WHERE clause of a SELECT statement, and so on.


If the component of a structure is itself a structure you access the sub-components by using the component selector again after the name of the main component. The first value assignment in the example accesses component MSGTY of MESSAGE, which itself is a component of nested structure CONNECTION_NESTED.

Hint

You can use code-completion to implement access to structure components. Place the cursor immediately after the structure component selector and press CTRL + SPACE to see a list of all available structure components.

The VALUE #( ) expression is an elegant way to assign values to a structured data object.

If you want to fill a whole structure, you can address each component individually as you saw in the previous example.

However, you can also use a VALUE #( ) expression to fill the structure. The expression constructs a structure, fills it with value and assigns the filled structure to a variable, in this case connection. The pound sign (#) tells the ABAP runtime environment to construct a structure with the same type as the target variable connection. In the brackets, you list the components of the structure that you want to fill (it does not have to be all of them) and assign a value to them. The value can be either a literal or the contents of a variable.

When you fill a structure in this way, the runtime system deletes all existing values from the structure before refilling it with the values from your expression.

Note

An assignment in the form connection = VALUE #( ). with just a blank between the brackets, fills all components of the structure with the type-specific initial value. This has the same effect as statement CLEAR connection.

In ABAP, you may only copy the contents of one structure directly into another structure using the notation <target structure> = <source structure> if the two structure types are compatible. This is generally only the case if both structures have the same type. If the structures have different types, two things can happen:

If one of the structures has a non-char-like component at a position where the other structure has a char-like component, direct assignment leads to a syntax error.
If both structures are char-like, or, in other words, both structures consist of char-like components, only, direct assignment is technically possible. But usually, the result will be wrong.
In the example, source structure and target structure are char-like. Therefore, direct assignment is technically possible. But because they are not compatible the result is wrong: The content of component carrier_name is copied to component message in the target structure.

Because there is no syntax error, you have to be extra careful when working with non-compatible char-like structures.

When you copy data between structures, you usually want to copy information from one field into the corresponding field of the target structure - airport_from_id to airport_from_id, airport_to_id to airport_to_id, and so on. To achieve this in ABAP, use the CORRESPONDING expression. This assigns values from <source_structure> to the corresponding, that is, identically-named components of . <target_structure>. You must remember the following points:

The fields must have identical names.
The components do not have to be in the same position or sequence in the two structures.
If the fields have different types, ABAP attempts a type conversion according to the predefined set of rules.
Note

The target structure is initialized before being re-filled with the result of the expression.
Try It Out: Access to Structured Data Objects
Like in the first exercise of this course, create a new global class that implements interface IF_OO_ADT_CLASSRUN.
Copy the following code snippet to the implementation part of method if_oo_adt_classrun~main( ):
Code Snippet

Copy code

Switch to dark mode

    TYPES: BEGIN OF st_connection,
             airport_from_id TYPE /dmo/airport_from_id,
             airport_to_id   TYPE /dmo/airport_to_id,
             carrier_name    TYPE /dmo/carrier_name,
           END OF st_connection.

    TYPES: BEGIN OF st_connection_nested,
             airport_from_id TYPE /dmo/airport_from_id,
             airport_to_id   TYPE /dmo/airport_to_id,
             message         TYPE symsg,
             carrier_name    TYPE /dmo/carrier_name,
           END OF st_connection_nested.

    DATA connection TYPE st_connection.
    DATA connection_nested TYPE st_Connection_nested.

* Example 1: Access to structure components
**********************************************************************

    connection-airport_from_id = 'ABC'.
    connection-airport_to_id   = 'XYZ'.
    connection-carrier_name    = 'My Airline'.

    "Access to sub-components of nested structure
    connection_nested-message-msgty = 'E'.
    connection_nested-message-msgid = 'ABC'.
    connection_nested-message-msgno = '123'.

* Example 2: Filling a structure with VALUE #(    ).
**********************************************************************
  
  CLEAR connection.

    connection = VALUE #( airport_from_id = 'ABC'
                          airport_to_id   = 'XYZ'
                          carrier_name    = 'My Airline'
                        ).

    " Nested VALUE to fill nested structure
    connection_nested = VALUE #( airport_from_id = 'ABC'
                                 airport_to_id   = 'XYZ'
                                 message         = VALUE #( msgty = 'E'
                                                            msgid = 'ABC'
                                                            msgno = '123' )
                                 carrier_name    = 'My Airline'
                         ).

* Example 3: Wrong result after direct assignment
**********************************************************************

    connection_nested = connection.

    out->write(  `-------------------------------------------------------------` ).
    out->write(  `Example 3: Wrong Result after direct assignment` ).

    out->write( data = connection
                name = `Source Structure:`).

    out->write( |Component connection_nested-message-msgid: { connection_nested-message-msgid }| ).
    out->write( |Component connection_nested-carrier_name : { connection_nested-carrier_name  }| ).

* Example 4: Assigning Structures using CORRESPONDING #( )
**********************************************************************
    CLEAR connection_nested.
    connection_nested = CORRESPONDING #(  connection ).  "

    out->write(  `-------------------------------------------------------------` ).
    out->write(  `Example 4: Correct Result after assignment with CORRESPONDING` ).

    out->write( data = connection
                name = `Source Structure:`).

    out->write( |Component connection_nested-message-msgid: { connection_nested-message-msgid }| ).
    out->write( |Component connection_nested-carrier_name : { connection_nested-carrier_name  }| ). 
Press CTRL + F3 to activate the class and F9 to execute the console app.
Analyze the console output. Debug the program, play around with the source code to get familiar with the concepts.
Structured Data Objects in ABAP SQL

The INTO clause of the SELECT statement will only work correctly if the number and types of the components of the structure correspond to the number and types of the columns specified in the FIELDS clause. In the above example, the statement can only work if the target structure connection has three components with the same type and length as the columns DepartureAirport, DestinationAirport, and \_Airline-Name listed in the FIELDS clause. Note that, in this case, the names do not have to be identical - the system fills the target structure from left to right.

If the field list in the FIELDS clause does not match the structure or table line type in the INTO clause, a runtime error will occur.

The example shows an easy technique to ensure that the target structure matches the field selection:

The target structure is typed with CDS view /DMO/I_Connection, which is the data source in the FROM clause.
The asterisk sign (*) after keyword FIELDS is a short notation to makes sure, that all fields of the view are part of the field selection. Exposed associations are ignored.
Note

This technique is also available when you read directly from a database table. Just like CDS view definitions, database table definitions can also serve as global structure types in ABAP.
The main advantage of this technique is, that the SELECT statement stays syntactically intact even if you or someone else makes changes to CDS view or database table. The most important drawback is, that you always read all fields from the database, whether you actually need them or not.

Note

Only use this technique for views and tables with a small number of fields and if you actually need all the fields. Unnecessary reading of data from the database is a major cause for performance problems.

Another way to avoid syntax errors is variant INTO CORRESPONDING FIELDS. This variant has the same effect as the CORRESPONDING #( ) operator that you learned about earlier. It ensures that data is copied between identically-named components. By defining the structure type according to your needs you can ensure that only the required data is read.

Once again, only the names must be identical. But to avoid problems you should make sure that identically-named components have compatible types. Otherwise the system attempts to convert the contents of the source field into the type of the target field. This can lead to data loss or (catchable) runtime errors.


If the field names in the data source and the component names in the target structure do not match, the combination of FIELDS * and INTO CORRESPONDING FIELDS OF does not work.

If you want to keep variant INTO CORRESPONDING FIELDS OF, you can define alias names for the selected fields in the field list. For this, add addition AS after the field name, followed by the alias name. In the example, the alias name for view field DepartureAirport is airport_from_id and the alias name for path expression \_Airline-Name is carrier_name. Based on this alias names, INTO CORRESPONDING FIELDS OF correctly identifies the structure component in which to store the retrieved data.


The simplest technique to avoid conflicts between the field selection and the target structure is an inline declaration in the INTO clause. The sequence, type and name of the inline declared structure is derived from the FIELD clause. Therefore the target structure always fits the field selection.

Note

Inline declarations are only supported after INTO. You cannot use inline declarations after INTO CORRESPONDING FIELDS OF.

If you use an inline declaration in the INTO clause, you have to provide a name for each element in the FIELDS clause. For fields of the data source, this can be the field name itself or, optionally an alias name. For expressions, the alias name becomes mandatory.

In the example, there is no alias for field DepartureAirport. The name of the field is used as component name in structure connection_inline. Field DestinationAirport has an optional alias ArrivalAirport. In this case the alias is used as component name. The alias for path expression \_Airline-Name is mandatory.


When working with a relational database you often face the problem that you have to read related data from different database tables. We already learned that associations in CDS views are an elegant way to perform this task.

If no CDS View with suitable associations exist you can implement SQL joins, instead. The example above illustrates the principle of joins:

We are interested in flight connections and the airports they connect with each other. We find the 3-letter IDs of the airports in database table /DMO/CONNECTION. The full names of the airports are stored in database table /DMO/AIRPORT.

To retrieve a connection with the departure airport name, in one SELECT statement, we read connection data from DB table /DMO/CONNECTION and join it with DB table /DMO/AIRPORT.

A join consists of the following building blocks:

Data Sources
The Database tables and views to join with each other. A single join always combines a left-hand data source with a right-hand data source. In the example above, table /DMO/CONNECTION is the left-hand data source and table /DMO/AIRPORT the right-hand data source. ABAP SQL also supports joins of joins (nested joins)
Join Condition
The join condition specifies which records of the right-hand data source belong to a record from the left-hand data source. In the example above, the related departure airport is identified by the value in columns CLIENT and AIRPORT_ID. The join condition reads:
/DMO/CONNECTION~CLIENT = /DMO/AIRPORT~CLIENT
AND
/DMO/CONNECTION~AIRPORT_FROM_ID = /DMO/AIRPORT~AIRPORT_ID
Join Type
The join type has an influence on the result if one of the data sources does not contain a matching records. ABAP SQL currently supports INNER JOIN, LEFT OUTER JOIN, and RIGHT OUTER JOIN. The most common join type is a LEFT OUTER JOIN.

The figure shows the ABAP SQL syntax for a join. In the FROM clause, the join type is specified by keywords LEFT OUTER JOIN between the left-hand data source /dmo/connection and the right-hand data source /dmo/airport. The syntax introduces alias names c and f for the data sources. Alias names for data sources are optional, unless a data source appears more than once in the join.

The join condition follows keyword ON. The separator between the data source or its alias and the field is the tilde sign (~).

Note

In ABAP SQL, it is not necessary to mention the client fields. They are added to the join condition by the database interface before the statement is sent to the database. If the FROM clause defines a join, you can use fields from both data sources in the FIELDS and WHERE clauses.

In this example, the SELECT statement not only read the departure airport name but also the destination airport name. To do so, the FROM clause defines a nested join:

The first join is a left outer join of tables /dmo/connection and /dmo/airport, introducing alias "f" (like "from") for the right-hand data source. This first join is then used as left-hand data source for a second left outer join that has table /dmo/airport as right-hand data source. Note that in this case alias "t" (for "to") is crucial to distinguish this appearance of table /dmo/airport from the previous one.

The FIELDS clause, lists the airport names from both data sources, introducing aliases airport_from_name and airport_to_name to distinguish them from each other.

Hint

The brackets around the first join are optional. If they are omitted, the joins in the from clause are evaluated from left to right.
Try It Out: Structured Data Objects in ABAP SQL
Like in the first exercise of this course, create a new global class that implements interface IF_OO_ADT_CLASSRUN.
Copy the following code snippet to the implementation part of method if_oo_adt_classrun~main( ):
Code Snippet

Copy code

Switch to dark mode

    TYPES: BEGIN OF st_connection,
             airport_from_id TYPE /dmo/airport_from_id,
             airport_to_id   TYPE /dmo/airport_to_id,
             carrier_name    TYPE /dmo/carrier_name,
           END OF st_connection.

    TYPES: BEGIN OF st_connection_short,
             DepartureAirport   TYPE /dmo/airport_from_id,
             DestinationAirport TYPE /dmo/airport_to_id,
           END OF st_connection_short.


    DATA connection TYPE st_connection.

    DATA connection_short TYPE st_connection_short.

    DATA connection_full TYPE /DMO/I_Connection.

* Example 1: Correspondence between FIELDS and INTO
**********************************************************************

    SELECT SINGLE
       FROM /DMO/I_Connection
     FIELDS DepartureAirport, DestinationAirport, \_Airline-Name
      WHERE AirlineID = 'LH'
        AND ConnectionID = '0400'
       INTO @connection.

    out->write(  `------------------------------` ).
    out->write(  `Example 1: Field List and INTO` ).
    out->write( connection ).

* Example 2: FIELDS *
**********************************************************************

    SELECT SINGLE
      FROM /DMO/I_Connection
    FIELDS *
     WHERE AirlineID = 'LH'
       AND ConnectionID = '0400'
      INTO @connection_full.

    out->write(  `----------------------------` ).
    out->write(  `Example 2: FIELDS * and INTO` ).
    out->write( connection_full ).

* Example 3: INTO CORRESPONDING FIELDS
**********************************************************************

    SELECT SINGLE
      FROM /DMO/I_Connection
    FIELDS *
     WHERE AirlineID    = 'LH'
       AND ConnectionID = '0400'
      INTO CORRESPONDING FIELDS OF @connection_short.

    out->write(  `----------------------------------------------------` ).
    out->write(  `Example 3: FIELDS * and INTO CORRESPONDING FIELDS OF` ).
    out->write( connection_short ).

* Example 4: Alias Names for Fields
**********************************************************************

    CLEAR connection.

    SELECT SINGLE
      FROM /DMO/I_Connection
    FIELDS DepartureAirport AS airport_from_id,
           \_Airline-Name   AS carrier_name
     WHERE AirlineID    = 'LH'
       AND ConnectionID = '0400'
      INTO CORRESPONDING FIELDS OF @connection.

    out->write(  `---------------------------------------------------` ).
    out->write(  `Example 4: Aliases and INTO CORRESPONDING FIELDS OF` ).
    out->write( connection ).

* Example 5: Inline Declaration
**********************************************************************

    SELECT SINGLE
      FROM /DMO/I_Connection
    FIELDS DepartureAirport,
           DestinationAirport AS ArrivalAirport,
           \_Airline-Name     AS carrier_name
     WHERE AirlineID    = 'LH'
       AND ConnectionID = '0400'
      INTO @DATA(connection_inline).

    out->write(  `-----------------------------------------` ).
    out->write(  `Example 5: Aliases and Inline Declaration` ).
    out->write( connection_inline ).

* Example 6: Joins
**********************************************************************

    SELECT SINGLE
      FROM (  /dmo/connection AS c
      LEFT OUTER JOIN /dmo/airport AS f
        ON c~airport_from_id = f~airport_id )
      LEFT OUTER JOIN /dmo/airport AS t
        ON c~airport_to_id = t~airport_id
    FIELDS c~airport_from_id, c~airport_to_id,
           f~name AS airport_from_name, t~name AS airport_to_name
     WHERE c~carrier_id    = 'LH'
       AND c~connection_id = '0400'
      INTO @DATA(connection_join).

    out->write(  `------------------------------------------` ).
    out->write(  `Example 6: Join of Connection and Airports` ).
    out->write( connection_join ).
Press CTRL + F3 to activate the class and F9 to execute the console app.
Analyze the console output. Debug the program, play around with the source code to get familiar with the concepts.
Use a Structured Data Object
In this exercise, you declare a structured attribute, fill it using a SELECT statement and access the structure components.

Template:
/LRN/CL_S4D400_DBS_CDS (global Class)
Solution:
/LRN/CL_S4D400_STS_STRUCTURE (global Class)
Task 1: Copy Template
Copy the template class. Alternatively, copy your solution of the previous exercise.

Steps
Copy the class /LRN/CL_S4D400_DBS_CDS to a class in your own package (suggested name: ZCL_##_STRUCTURE, where ## stands for your group number).

Open the source code of the global class /LRN/CL_S4D400_DBS_CDS.

Link the Project Explorer view with the editor.

In the Project Explorer view, right-click the class /LRN/CL_S4D400_DBS_CDS to open the context menu.

From the context menu, choose Duplicate ....

Enter the name of your package in the Package field. In the Name field, enter the name ZCL_##_STRUCTURE, where ## stands for your group number.

Adjust the description and choose Next.

Confirm the transport request and choose Finish.

Task 2: Declare a Structured Data Object
In the local class, declare a structured attribute details to replace the scalar attributes airport_from_id, airport_to_id, and carrier_name. Begin by defining a private structure type st_details inside the local class.

Steps
Switch to the local class lcl_connection.

In the global class, choose Local Types.

Define a private structure type st_details with the following components:

Components of structure type st_details:
Component Name	Data Type
DepartureAirport	/dmo/airport_from_id
DestinationAirport	/dmo/airport_to_id
AirlineName	/dmo/carrier_name
After line PRIVATE SECTION., add the following code:

Code Snippet

Copy code

Switch to dark mode

    TYPES: 
      BEGIN OF st_details,
        DepartureAirport   TYPE /dmo/airport_from_id,
        DestinationAirport TYPE   /dmo/airport_to_id,
        AirlineName        TYPE   /dmo/carrier_name,
      END OF st_details.
Comment or remove the declaration of attributes airport_from_id, airport_to_id, and carrier_name.

Select the lines with the three DATA statements.

Press Ctrl + < to add a star sign (*) in front of each selected line.

Declare a new private instance attribute details and type it with structure type st_details..

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

*    DATA airport_from_id TYPE /dmo/airport_from_id.
*    DATA airport_to_id   TYPE /dmo/airport_to_id.
*
*    DATA carrier_name    TYPE /dmo/carrier_name.

    DATA details TYPE st_details.

Task 3: Access Structure Components
Use the components of the structured attribute details in the method get_output.

Steps
Adjust the implementation of the method get_output. Replace any access to the attributes airport_from_id, airport_to_id, and carrier_name with the corresponding component of attribute details.

Hint

Do not type in the component names manually! After typing the structure component selector (-), press Ctrl + Space to get a list of all components.
Navigate to the implementation of the method get_output.

Adjust the APPEND statements as follows:

Code Snippet

Copy code

Switch to dark mode

*    APPEND |--------------------------------|             TO r_output.
*    APPEND |Carrier:     { carrier_id } { carrier_name }| TO r_output.
*    APPEND |Connection:  { connection_id   }|             TO r_output.
*    APPEND |Departure:   { airport_from_id }|             TO r_output.
*    APPEND |Destination: { airport_to_id   }|             TO r_output.

    APPEND |--------------------------------|                    TO r_output.
    APPEND |Carrier:     { carrier_id } { details-airlinename }| TO r_output.
    APPEND |Connection:  { connection_id   }|                    TO r_output.
    APPEND |Departure:   { details-departureairport     }|       TO r_output.
    APPEND |Destination: { details-destinationairport   }|       TO r_output.
Task 4: Fill the Structured Attribute in the SELECT Statement
Use the structured attribute as the target of the SELECT statement in the constructor method.

Steps
Adjust the SELECT statement in the implementation of the constructor method. Replace the list of data objects in the INTO clause with the structured attribute details.

Navigate to the implementation of method constructor.

Adjust the SELECT statement as follows:

Code Snippet

Copy code

Switch to dark mode

SELECT SINGLE
      FROM /DMO/I_Connection
    FIELDS DepartureAirport, DestinationAirport, \_Airline-Name 
     WHERE AirlineID    = @i_carrier_id
       AND ConnectionID = @i_connection_id
*       INTO ( @airport_from_id, @airport_to_id, @carrier_name  ).
      INTO @details.
Optional: Use syntax variant INTO CORRESPONDING FIELDS OF @details..

In the SELECT statement, replace INTO @details.with the following code:

Code Snippet

Copy code

Switch to dark mode

  INTO CORRESPONDING FIELDS OF @details.
Add alias name AirlineName for the path expression.

The SELECT statement should now look like this:

Code Snippet

Copy code

Switch to dark mode

SELECT SINGLE
      FROM /DMO/I_Connection
    FIELDS DepartureAirport, DestinationAirport, \_Airline-Name as AirlineName
     WHERE AirlineID    = @i_carrier_id
       AND ConnectionID = @i_connection_id
      INTO CORRESPONDING FIELDS OF @details.
Activate the class. Execute it and analyze the console output. Check that the output displays data for all attributes.

Press Ctrl + F3 to activate the class.

Press F9 to run the class.

Declaring a Complex Internal Table
Objective

After completing this lesson, you will be able to declare a complex internal table.
Properties of Complex Internal Tables

The internal tables we have used so far had a scalar data type as their row type. In the example shown in the figures here, the row type of internal table numbers is the ABAP built-in type I.

We refer to these kinds of internal tables as simple internal tables.


We speak of a complex internal table if the row type is a structured data type.

While a simple internal table has only one nameless column, a complex internal table consists of several columns, each of them with the name and type of the corresponding component of the structured row type. In the example, the row type of internal table connection is a structured type with five components: carrier_id, connection_id, airport_from_id, airport_to_id, and carrier_name. Consequently, internal table connections has five columns with those names.

Note

The columns in the examples in the figures, Reminder: Simple Internal Tables and Internal Tables with Structured Row Type, all have scalar types. More generally, a column of an internal table could also be of structured type or even have a table type. In the latter case, we talk of a nested internal table.

Up to now, we have addressed the rows of an internal table by their position. This is called an index access.

With the named columns of a complex internal table, key access becomes more important. Key access means addressing a row of the internal table by looking for particular values in particular columns. The columns in which you search can be any columns of the internal table.

Index access to an internal table is always very fast, even if the internal table contains many rows. Key access, however, can become very slow if the table contains a lot of rows. Choosing the right access type for the internal table can improve the performance of a key access.


Every internal table has one of three access types. The access type determines how data is stored in the table and, based on that, how the system reads the table to retrieve the data.

The different types of tables are as follows:

Standard Table
In a standard table, the contents are not stored in a particular sort order. By default, new records are appended to the end of the table. In order to retrieve data by key, the system must read it sequentially, which can lead to long retrieval times if the table is very large. The simple internal tables we used so far were standard tables.
Sorted Table
In a sorted table, the contents of the table are always sorted according to the key fields in ascending order. When you insert a new record into the table, the system ensures that it is placed at the correct position. Since the data is always sorted, the system can retrieve records more efficiently than from a standard table (as long as you follow particular rules).
Hashed Table
Hashed tables are managed using a special hash algorithm. This ensures that the system can retrieve records very quickly even if the table is extremely large. However, this performance gain only works in very particular cases.

Every internal table has a key. In standard tables, the key does not play a particularly significant role. For sorted and hashed tables, the key is very important as it determines the way in which the data will be managed in the table. Crucially, sorted and hashed tables are only faster for key access that addresses all or at least a subset of the key fields.

A further attribute of the table key is its uniqueness. You will sometimes want to allow duplicate entries in an internal table, and sometimes you will want to ensure that the key is unique. Here, the following rules apply:

Duplicates are always allowed in standard tables
Duplicates are never allowed in hashed tables
For a sorted table, you choose in the definition whether the key is to be unique or non-unique.
Note

Internal tables may also have secondary keys. Secondary keys are a way of improving the performance of key accesses to internal tables that use different combinations of fields. You will find more information about secondary keys in the ABAP syntax documentation.
Complex Table Types
Watch this video to see some examples for the declaration of complex internal tables.


Furthermore, it is good programming style to define the data type first and then to create a variable that refers to the type.

Instead of specifying the access type and key of an internal table in the DATA statement, you should use a named table type. If you need the table type only locally in a method or in connection with a given class, you can define it using the TYPES statement.

The example defines a structured type st_connection, first. With this structured type as row type it then defines table type tt_connections. Finally, the declaration of internal table connections_5 refers to the table type.

If you need the table type globally, you can use a global table type.

A global table type is a repository object that can be used as data type anywhere in the system. ADT provides a dedicated editor for this kind of repository object. The tool consists of the following frames:

The following video shows how to define table types locally.

Try It Out: Complex Table Types
Like in the first exercise of this course, create a new global class that implements interface IF_OO_ADT_CLASSRUN.
Copy the following code snippet to the implementation part of method, if_oo_adt_classrun~main( ):
Code Snippet

Copy code

Switch to dark mode

    TYPES: BEGIN OF st_connection,
             carrier_id      TYPE /dmo/carrier_id,
             connection_id   TYPE /dmo/connection_id,
             airport_from_id TYPE /dmo/airport_from_id,
             airport_to_id   TYPE /dmo/airport_to_id,
             carrier_name    TYPE /dmo/carrier_name,
           END OF st_connection.


* Example 1 : Simple and Complex Internal Table
**********************************************************************

    " simple table (scalar row type)
    DATA numbers TYPE TABLE OF i.
    " complex table (structured row type)
    DATA connections TYPE TABLE OF st_connection.

    out->write(  `--------------------------------------------` ).
    out->write(  `Example 1: Simple and Complex Internal Table` ).
    out->write( data = numbers
                name = `Simple Table NUMBERS:`).
    out->write( data = connections
                name = `Complex Table CONNECTIONS:`).

* Example 2 : Complex Internal Tables
**********************************************************************

    " standard table with non-unique standard key (short form)
    DATA connections_1 TYPE TABLE OF st_connection.

    " standard table with non-unique standard key (explicit form)
    DATA connections_2 TYPE STANDARD TABLE OF st_connection
                            WITH NON-UNIQUE DEFAULT KEY.

    " sorted table with non-unique explicit key
    DATA connections_3  TYPE SORTED TABLE OF st_connection
                             WITH NON-UNIQUE KEY airport_from_id
                                                 airport_to_id.

    " sorted hashed with unique explicit key
    DATA connections_4  TYPE HASHED TABLE OF st_connection
                             WITH UNIQUE KEY carrier_id
                                             connection_id.

* Example 3 : Local Table Type
**********************************************************************

    TYPES tt_connections TYPE SORTED TABLE OF st_connection
                              WITH UNIQUE KEY carrier_id
                                              connection_id.

    DATA connections_5 TYPE tt_connections.

* Example 4 : Global Table Type
**********************************************************************

    DATA flights  TYPE /dmo/t_flight.

    out->write(  `------------------------------------------` ).
    out->write(  `Example 4: Global Table TYpe /DMO/T_FLIGHT` ).
    out->write(  data = flights
                 name = `Internal Table FLIGHTS:` ).
Press CTRL + F3 on your keyboard to activate the class and F9 to execute the console app.
Analyze the console output. Debug the program, play around with the source code to get familiar with the concepts.
Was this lesson helpful?


Yes

No
Next lesson

Working with Complex Internal Tables
Objectives

After completing this lesson, you will be able to:
Fill complex internal tables with data.
Access the content of complex internal tables.
Use complex internal tables in ABAP SQL.
Complex Internal Table Filling

As you already learned, the simplest way to add a new row to an internal table is the APPEND statement with a data object whose type corresponds to the row type of the internal table. This data object is sometimes referred to as work area.

For simple internal tables the work area used in APPEND can be a scalar variable, constant, or a literal. For complex internal tables, the work area has to be structured.

In the example, structured variable connection is used to fill internal table connections.

In principle, there are two ways to declare work area connection:

Reference the row type st_connection directly
Reference the row type indirectly using LIKE LINE OF <internal_table>.
Defining work areas with LIKE LINE OF has two advantages:

It reveals the purpose of the structured variable as work area for the internal table
It ensures that the work area fits to the internal table, even if the definition of the internal table changes

If you do not fill the work area before the APPEND statement, the new row of the internal table will be filled with type-specific initial values.

Hint

You get the same result with the special variant APPEND INITIAL LINE TO <internal_table>. This variant does not even require a work area.
To fill the structured work area, you can either fill the individual components or, as you can see in the example, use a VALUE #( ) expression.


As you can see in the example, you can also use a VALUE #( ) expression directly in the APPEND statement. In this case, you do not need a work area.

Note

This can have a positive effect on the overall memory consumption of your program.

There is a variant of the VALUE #( ) expression that you can assign directly to an internal table. In this variant of VALUE #( ) additional pairs of brackets are used to separate the table rows from each other.

The code example fills internal table carriers with three rows, each with a different value for carrier_id and carrier_name. As a result of this, column currency_code is not mentioned, it is filled with the type specific initial value.

Note

With the assignment above, all existing table rows are removed before the table is filled with the new rows.

To copy data between identically-named fields of two internal tables, use the CORRESPONDING operator. This works similarly to CORRESPONDING for structures: for each row of the source internal table, the system creates a new row in the target internal table and copies data between identically-named fields. Source fields for which there is no identically named field in the target are not copied. Target fields for which there is no identically named field in the source are filled with type-specific initial values.

In the example, the source internal table carriers contains three rows. Therefore, after the value assignment, the target internal table connections also contains three rows.

Fields carrier_id and carrier_name exist in both internal tables. They are copied from source to target. Field currency_code only exists in the source. It is not copied. Fields connection_id, airport_from_id, and airport_to_id exist only in the target. They are filled with initial values.

Note

If the target internal table contains data before the assignment, the system deletes it.
How To Debug Complex Internal Tables
Demo
Start Demo
Try It Out: Filling Complex Internal Tables
As it is in the first exercise of this course, create a new global class that implements interface IF_OO_ADT_CLASSRUN.
Copy the following code snippet to the implementation part of method if_oo_adt_classrun~main( ):
Code Snippet

Copy code

Switch to dark mode

    TYPES: BEGIN OF st_connection,
             carrier_id      TYPE /dmo/carrier_id,
             connection_id   TYPE /dmo/connection_id,
             airport_from_id TYPE /dmo/airport_from_id,
             airport_to_id   TYPE /dmo/airport_to_id,
             carrier_name    TYPE /dmo/carrier_name,
           END OF st_connection.

    TYPES tt_connections TYPE STANDARD TABLE OF   st_connection
                              WITH NON-UNIQUE KEY carrier_id
                                                  connection_id.

    DATA connections TYPE tt_connections.

    TYPES: BEGIN OF st_carrier,
             carrier_id    TYPE /dmo/carrier_id,
             carrier_name  TYPE /dmo/carrier_name,
             currency_code TYPE /dmo/currency_code,
           END OF st_carrier.

    TYPES tt_carriers TYPE STANDARD TABLE OF st_carrier
                          WITH NON-UNIQUE KEY carrier_id.

    DATA carriers TYPE tt_carriers.

* Example 1: APPEND with structured data object (work area)
**********************************************************************

*    DATA connection  TYPE st_connection.
    " Declare the work area with LIKE LINE OF
    DATA connection LIKE LINE OF connections.


*    connection-carrier_id       = 'NN'.
*    connection-connection_id    = '1234'.
*    connection-airport_from_id  = 'ABC'.
*    connection-airport_to_id    = 'XYZ'.
*    connection-carrier_name     = 'My Airline'.

    " Use VALUE #( ) instead assignment to individual components
    connection = VALUE #( carrier_id       = 'NN'
                          connection_id    = '1234'
                          airport_from_id  = 'ABC'
                          airport_to_id    = 'XYZ'
                          carrier_name     = 'My Airline' ).

    APPEND connection TO connections.

    out->write(  `--------------------------------` ).
    out->write(  `Example 1: APPEND with Work Area` ).
    out->write(  connections ).

* Example 2: APPEND with VALUE #( ) expression
**********************************************************************

    APPEND VALUE #( carrier_id       = 'NN'
                    connection_id    = '1234'
                    airport_from_id  = 'ABC'
                    airport_to_id    = 'XYZ'
                    carrier_name     = 'My Airline'
                  )
       TO connections.

    out->write(  `----------------------------` ).
    out->write(  `Example 2: Append with VALUE` ).
    out->write(  connections ).

* Example 3: Filling an Internal Table with Several Rows
**********************************************************************

    carriers = VALUE #(  (  carrier_id = 'AA' carrier_name = 'American Airlines' )
                         (  carrier_id = 'JL' carrier_name = 'Japan Airlines'    )
                         (  carrier_id = 'SQ' carrier_name = 'Singapore Airlines')
                      ).

    out->write(  `-----------------------------------------` ).
    out->write(  `Example 3: Fill Internal Table with VALUE` ).
    out->write(  carriers ).

* Example 4: Filling one Internal Table from Another
**********************************************************************

    connections = CORRESPONDING #( carriers ).

    out->write(  `--------------------------------------------` ).
    out->write(  `Example 4: CORRESPONDING for Internal Tables` ).
    out->write(  data = carriers
                 name = `Source Table CARRIERS:`).
    out->write(  data = connections
                 name = `Target Table CONNECTIONS:`).
Press CTRL + F3 on your keyboard to activate the class and F9 to execute the console app.
Analyze the console output. Debug the program, play around with the source code to get familiar with the concepts.
Access to Complex Internal Tables

Earlier in this course, you learned how to retrieve a single row from a simple internal table using an internal table expression. Back then we used an index access, that is, we identified the row through its position in the internal table. This index access works for complex internal tables in just the same way. For complex internal tables, however, internal table expressions with key access become important, where you identify the row through its content.

Note

Even though this is called a key access, you can use any fields for the selection, not only key fields of the internal table. If more than one row fulfills the requirement, the first row is returned, that is, the row with the lowest index.
The example reads a single row from internal table connections. The key of this internal table consists of fields, carrier_id and connection_id, but the key access uses airport_from_id and airport_to_id to identify the row. The Internal table contains two connections from airport SFO to SIN, so the first of them is returned.

Remember that the ABAP runtime raises exception CX_SY_ITAB_LINE_NOT_FOUND if none of the rows fulfills the requirement. Handle this exception in a TRY … CATCH … ENDTRY structure to avoid runtime errors

To process multiple lines of an internal table by specifying fields, you use LOOP AT <internal table> INTO <target> WHERE <condition>. The WHERE condition can contain any number of constituent expressions joined using AND and OR. Within the expressions, you can use not just the equals operator (=) but also operators >, >=, <, <=, <> and BETWEEN.


After reading the content of a table row into a work area, you sometimes want to write changes from the work area back into the internal table. One way to do this is the MODIFY TABLE statement.

This statement is a key access because the system uses the content of the key fields in the work area to identify the table row that needs to be modified. It then overwrites this table row with the contents of the work area.

In the example, the work area carrier contains value 'JL' in key field, carrier_id. Based on this value, the system identifies the second row to be updated. This row is then updated with the values from the work area.

Note

You can only change non-key fields with MODIFY TABLE. The statement does not support changes to key fields.


The MODIFY statement (without keyword TABLE!) does not distinguish between key fields and non-key fields. It overwrites the entire table row with new values from the work area. This statement is considered an index access because the row to be updated is identified by its position in the internal table. Usually, the index is specified explicitly using addition INDEX followed by an integer argument (literal, constant, variable, expression).

Note

There is also a special variant without addition INDEX. We will discuss this variant next.
In the example, the MODIFY statement uses the INDEX addition to address the first table row. In this row, all fields are overwritten with the values from the work area, even key field carrier_id.


There will often be times when you need to modify the contents of multiple rows of an internal table, or maybe even all of them. To do this, you implement a loop over the table, which places each row you need to change successively into a work area. Within the loop, you first change the contents of the work area and then write the changes back into the internal table using the MODIFY statement.

Note

If you do not write your changes back into the table, the changes will be lost when the work area is filled with the data from next row.
In the example, the loop reads all rows of internal table carriers for which field currency_code is not yet filled. This is the case for the last two rows. For each of these rows the program replaces the initial value in field currency_code with the new value 'USD'. Finally, it uses the MODIFY statement to overwrite the current row with the updated values.

Instead of specifying the index explicitly, the code example uses a short form of the MODIFY statement where the INDEX addition is missing. This short form is only allowed between LOOP … ENDLOOP. Only there the system can implicitly update the row it is currently working on.

If you use MODIFY without INDEX outside of LOOP…ENDLOOP, the system does not know which row to modify and triggers a non-catchable runtime error. To avoid such runtime errors, make sure not to ignore the related warning from the syntax check!
Try It Out: Access to Complex Internal Tables
As with the first exercise of this course, create a new global class that implements the interface, IF_OO_ADT_CLASSRUN.
Copy the following code snippet to the implementation part of method if_oo_adt_classrun~main( ):
Code Snippet

Copy code

Switch to dark mode

  TYPES: BEGIN OF st_connection,
             carrier_id      TYPE /dmo/carrier_id,
             connection_id   TYPE /dmo/connection_id,
             airport_from_id TYPE /dmo/airport_from_id,
             airport_to_id   TYPE /dmo/airport_to_id,
             carrier_name    TYPE /dmo/carrier_name,
           END OF st_connection.

    TYPES tt_connections TYPE SORTED TABLE OF   st_connection
                              WITH NON-UNIQUE KEY carrier_id
                                                  connection_id.

    DATA connections TYPE tt_connections.
    DATA connection  LIKE LINE OF connections.

    TYPES: BEGIN OF st_carrier,
             carrier_id    TYPE /dmo/carrier_id,
             currency_code TYPE /dmo/currency_code,
           END OF st_carrier.

    DATA carriers TYPE STANDARD TABLE OF st_carrier
                       WITH NON-UNIQUE KEY carrier_id.

    DATA carrier LIKE LINE OF carriers.

* Preparation: Fill internal tables with data
**********************************************************************
    connections = VALUE #(  ( carrier_id      = 'JL'
                              connection_id   = '0408'
                              airport_from_id = 'FRA'
                              airport_to_id   = 'NRT'
                              carrier_name    = 'Japan Airlines'
                            )
                            ( carrier_id      = 'AA'
                              connection_id   = '0017'
                              airport_from_id = 'MIA'
                              airport_to_id   = 'HAV'
                              carrier_name    = 'American Airlines'
                            )
                            ( carrier_id      = 'SQ'
                              connection_id   = '0001'
                              airport_from_id = 'SFO'
                              airport_to_id   = 'SIN'
                              carrier_name    = 'Singapore Airlines'
                            )
                            ( carrier_id      = 'UA'
                              connection_id   = '0078'
                              airport_from_id = 'SFO'
                              airport_to_id   = 'SIN'
                              carrier_name    = 'United Airlines'
                            )
                           ).

    carriers = VALUE #(  (  carrier_id    = 'SQ'
                            currency_code = ' '
                         )
                         (  carrier_id    = 'JL'
                            currency_code = ' '
                         )
                         (  carrier_id    = 'AA'
                            currency_code = ' '
                         )
                         (  carrier_id    = 'UA'
                            currency_code = ' '
                         )
                      ).

* Example 1: Table Expression with Key Access
**********************************************************************
    out->write(  `--------------------------------------------` ).
    out->write(  `Example 1: Table Expressions with Key Access` ).

    out->write(  data = connections
                 name = `Internal Table CONNECTIONS: ` ).

    " with key fields
    connection = connections[ carrier_id    = 'SQ'
                              connection_id = '0001' ].

    out->write(  data = connection
                 name = `CARRIER_ID = 'SQ' AND CONNECTION_ID = '001':` ).

    " with non-key fields
    connection = connections[ airport_from_id = 'SFO'
                              airport_to_id   = 'SIN' ].
    out->write(  data = connection
                 name = `AIRPORT_FROM_ID = 'SFO' AND AIRPORT_TO_ID = 'SIN':` ).

* Example 2: LOOP with key access
**********************************************************************

    out->write(  `-------------------------------` ).
    out->write(  `Example 2: LOOP with Key Access` ).

    LOOP AT connections INTO connection
                       WHERE airport_from_id <> 'MIA'.

      "do something with the content of connection
      out->write( data = connection
                  name = |This is row number { sy-tabix }: | ).

    ENDLOOP.

* Example 3: MODIFY TABLE (key access)
**********************************************************************
    out->write(  `-----------------------------------` ).
    out->write(  `Example 3: MODIFY TABLE (key access` ).

    out->write(  data = carriers
                 name = `Table CARRRIERS before MODIFY TABLE:`).

    carrier = carriers[  carrier_id = 'JL' ].
    carrier-currency_code = 'JPY'.
    MODIFY TABLE carriers FROM carrier.

    out->write(  data = carriers
                 name = `Table CARRRIERS after MODIFY TABLE:`).

* Example 4: MODIFY (index access)
**********************************************************************
    out->write(  `--------------------------------` ).
    out->write(  `Example 4: MODIFY (index access)` ).

    carrier-carrier_id    = 'LH'.
    carrier-currency_code = 'EUR'.
    MODIFY carriers FROM carrier INDEX 1.

    out->write(  data = carriers
                 name = `Table CARRRIERS after MODIFY:`).

* Example 5: MODIFY in a LOOP
**********************************************************************
    out->write(  `----------------------------` ).
    out->write(  `Example 5: MODIFY  in a LOOP` ).

    LOOP AT carriers INTO carrier
                    WHERE currency_code IS INITIAL.

      carrier-currency_code = 'USD'.
      MODIFY carriers FROM carrier.

    ENDLOOP.

    out->write(  data = carriers
                 name = `Table CARRRIERS after the LOOP:`).
Press CTRL + F3 on your keyboard to activate the class and F9 to execute the console app.
Analyze the console output. Debug the program, play around with the source code to get familiar with the concepts.
Complex Internal Tables in ABAP SQL

The ABAP SQL statement, SELECT, reads data from a database table or a CDS View. When you use the SINGLE option, exactly one record is read from the database, even if more data exist that meets the conditions in the WHERE clause.

As you learned earlier, one way to receive this single record result is structured variable after keyword INTO.


If you use SELECT without SINGLE, you indicate that you are interested in all records that match the conditions in the WHERE clause. You then have to make sure that you can actually receive and store multiple records. The obvious way to do this is the usage of a complex internal table as target of the SELECT statement. This is possible but it requires addition TABLE between keyword INTO and the name of the internal table.

In the example, we want to read all three airports related to London and not just a single one of them. Therefore, we leave out the keyword SINGLE after SELECT, add keyword TABLE after INTO and use internal table airports_full as target of the SELECT statement.

The example uses an explicit field list after FIELDS that matches the columns of internal table airports_full. Of course, you can also use FIELDS *, INTO CORRESPONDING FIELDS OF TABLE, and alias names in the field list.


This example uses FIELDS * instead of an explicit field list and INTO CORRESPONDING FIELDS OF TABLE instead of INTO TABLE.

As the row type of internal table airports contains only two components AirportID and Name, only the fields with the same name are read from the database.


If you use DATA( ) in a SELECT statement after addition INTO TABLE, you inline declare an internal table. The row type of this internal table is derived from the FIELDS clause. For table fields and view elements an alias name is optional. For expressions in the FIELDS clause, an alias name is mandatory if the INTO clause contains an inline declaration.

Note

Inline declarations of internal tables are only supported after INTO TABLE. You cannot use inline declarations after INTO CORRESPONDING FIELDS OF TABLE.
Inline-declared internal tables are always standard tables without a key. You cannot declare sorted or hashed tables using inline declarations. This can cause performance problems if you fill the internal table with many rows and use key access a lot.

When you are reading multiple records from the database, some special SQL techniques become particularly interesting. One of these techniques is the UNION directive to combine the results of several SELECT statements.

The figure illustrates the combination of two SELECT results:

The first SELECT result reads ID and NAME of all carriers with CURRENCY_CODE = 'GBP'. The second SELECT reads ID and NAME of all airports with CITY = 'London'. The first SELECT returns one record, the second SELECT returns three records. Instead of retrieving these results separately, they are combined into one result with four records. It is important to point out that this happens inside the database.

A prerequisite for this technique is, of course, that the two results are compatible with each other, that is, that they have the same number of fields, the same field names. It is beneficial, though not necessary, that the types of the fields are also the same.


The ABAP SQL syntax for this example consists of two SELECT statements. Each SELECT statement has its own FROM clause, FIELDS clause, and WHERE clause, but there is only one INTO clause at the very end. The two SELECT statements are connected by keywords UNION ALL.

Note

With UNION instead of UNION ALL, the database would look for and eliminate duplicates before returning the result. We use UNION ALL to avoid this unnecessary additional load on the database.
Both field lists consist of three elements, the first and second element have identical alias names in both FIELDS clauses. The third field does not need an alias because the field name is the same in both CDS Views.

Note

The first element in FIELDS is a literal text that allows us to distinguish between Airlines and Airports in the combined result.
Try It Out: Internal Tables in ABAP SQL
As in the first exercise of this course, create a new global class that implements interface IF_OO_ADT_CLASSRUN.
Copy the following code snippet to the implementation part of method if_oo_adt_classrun~main( ):
Code Snippet

Copy code

Switch to dark mode

    TYPES: BEGIN OF st_airport,
             airportid TYPE /dmo/airport_id,
             name      TYPE /dmo/airport_name,
           END OF st_airport.

    TYPES tt_airports TYPE STANDARD TABLE OF st_airport
                          WITH NON-UNIQUE KEY airportid.

    DATA airports TYPE tt_airports.


* Example 1: Structured Variables in SELECT SINGLE ... INTO ...
**********************************************************************

    DATA airport_full TYPE /DMO/I_Airport.

    SELECT SINGLE
      FROM /DMO/I_Airport
    FIELDS AirportID, Name, City, CountryCode
     WHERE City = 'Zurich'
      INTO @airport_full.

    out->write(  `-------------------------------------` ).
    out->write(  `Example 1: SELECT SINGLE ... INTO ...` ).
    out->write(  data = airport_full
                 name = `One of the airports in Zurich (Structure):` ).

* Example 2: Internal Tables in SELECT ... INTO TABLE ...
**********************************************************************

    DATA airports_full TYPE STANDARD TABLE OF /DMO/I_Airport
                            WITH NON-UNIQUE KEY AirportID.

    SELECT
      FROM /DMO/I_Airport
    FIELDS airportid, Name, City, CountryCode
     WHERE City = 'London'
      INTO TABLE @airports_full.

    out->write(  `------------------------------------` ).
    out->write(  `Example 2: SELECT ... INTO TABLE ...` ).
    out->write(  data = airports_full
                 name = `All airports in London (Internal Table):` ).

* Example 3: FIELDS * and INTO CORRESPONDING FIELDS OF TABLE
**********************************************************************

    SELECT
      FROM /DMO/I_Airport
    FIELDS *
     WHERE City = 'London'
      INTO CORRESPONDING FIELDS OF TABLE @airports.

    out->write(  `----------------------------------------------------------` ).
    out->write(  `Example 3: FIELDS * and INTO CORRESPONDING FIELDS OF TABLE` ).
    out->write(  data = airports
                 name = `Internal Table AIRPORTS:` ).

* Example 4: Inline Declaration
**********************************************************************

    SELECT
      FROM /DMO/I_airport
    FIELDS AirportID, Name AS AirportName
     WHERE City = 'London'
     INTO TABLE @DATA(airports_inline).

    out->write(  `----------------------------------------------------------` ).
    out->write(  `Example 4: Inline Declaration after INTO TABLE` ).
    out->write(  data = airports_inline
                 name = `Internal Table AIRPORTS_INLINE:` ).

** Example 4: ORDER BY and DISTINCT
***********************************************************************
*
*    SELECT
*      FROM /DMO/I_Airport
*    FIELDS DISTINCT CountryCode
*     ORDER BY CountryCode
*     INTO TABLE @DATA(countryCodes).
*
*    out->write(  countryCodes ).

* Example 5: UNION (ALL)
**********************************************************************

    SELECT FROM /DMO/I_Carrier
           FIELDS 'Airline' AS type, AirlineID AS Id, Name
           WHERE CurrencyCode = 'GBP'

    UNION ALL

    SELECT FROM /DMO/I_Airport
           FIELDS 'Airport' AS type, AirportID AS Id,  Name
           WHERE City = 'London'
*    ORDER BY type, Id
    INTO TABLE @DATA(names).

    out->write(  `----------------------------------------------` ).
    out->write(  `Example 5: UNION ALL of Airlines and Airports ` ).
    out->write(  data = names
                 name = `ID and Name of Airlines and Airports:` ).
Press CTRL + F3 on your keyboard to activate the class and F9 to execute the console app.
Analyze the console output. Debug the program, play around with the source code to get familiar with the concepts.
Use a Complex Internal Table
In this exercise, you declare a table-like attribute, fill it using a SELECT statement and access the content.

Template:
/LRN/CL_S4D400_STS_STRUCTURE (global Class)
Solution:
/LRN/CL_S4D400_ITS_ITAB (global Class)
Task 1: Copy Template
Copy the template class. Alternatively, copy your solution of the previous exercise.

Steps
Copy the class /LRN/CL_S4D400_STS_STRUCTURE to a class in your own package (suggested name: ZCL_##_ITAB, where ## stands for your group number).

Open the source code of the global class /LRN/CL_S4D400_STS_STRUCTURE.

Link the Project Explorer view with the editor.

In the Project Explorer view, right-click the class /LRN/CL_S4D400_STS_STRUCTURE to open the context menu.

From the context menu, choose Duplicate ....

Enter the name of your package in the Package field. In the Name field, enter the name ZCL_##_ITAB, where ## stands for your group number.

Adjust the description and choose Next.

Confirm the transport request and choose Finish.

Task 2: Declare an Internal Table
In the local class, declare a static, table-like attribute airports to buffer detail information on all available airports. Begin by defining a private structure type st_airport and a table type tt_airports inside the local class.

Steps
Switch to the local class lcl_connection.

In the global class, choose Local Types.

Define a private structure type st_airport with the following components:

Components of structure type st_airport:
Component Name	Data Type
AirportID	/dmo/airport_id
Name	/dmo/airport_name
Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

   TYPES:
      BEGIN OF st_details,
        DepartureAirport   TYPE /dmo/airport_from_id,
        DestinationAirport TYPE /dmo/airport_to_id,
        AirlineName        TYPE /dmo/carrier_name,
      END OF st_details.

    TYPES:
      BEGIN OF st_airport,
        AirportId TYPE /dmo/airport_id,
        Name      TYPE /dmo/airport_name,
      END OF st_airport.
Define a private table type tt_airports with the following properties:

Properties of table type tt_airports:
Property	Value
Line type	st_airport
Table kind	STANDARD TABLE
Key Definition	NON-UNIQUE DEFAULT KEY
Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

 TYPES:
      BEGIN OF st_airport,
        AirportId TYPE /dmo/airport_id,
        Name      TYPE /dmo/airport_name,
      END OF st_airport.

    TYPES tt_airports TYPE STANDARD TABLE OF st_airport
                           WITH NON-UNIQUE DEFAULT KEY.
Declare a new private static attribute airports and type it with table type tt_airports..

At the end of the class definition, add the following code:

Code Snippet

Copy code

Switch to dark mode

  CLASS-DATA airports TYPE tt_airports.
Task 3: Fill the Static Attribute in a Class Constructor
Define a class constructor and implement a SELECT statement that reads all available airports from the CDS view entity /DMO/I_Airports into the static attribute Airports.

Steps
Add a class constructor to the local class lcl_connection using a quick fix.

Place the cursor on the name of the class and press Ctrl + 1.

Double-click on Generate class constructor.

In the class constructor, implement a SELECT statement that reads all data sets from the CDS view entity /DMO/I_Airports into the static attribute Airports .

Navigate to the implementation of the method class_constructor.

Inside the method implementation, add the following code:

Code Snippet

Copy code

Switch to dark mode

     SELECT FROM /DMO/I_Airport
          FIELDS AirportID, Name
            INTO TABLE @airports.
Task 4: Access the Content of the Internal Table
Use the content of internal table Airports in the method get_output to add the airport names to the output.

Steps
Navigate to the implementation of the method get_output.

Proceed as you have done in previous exercises.

At the beginning of the method, read the details of the departure airport into a structured data object departure.

Hint

Use a table expression Airports[ ... ] and an inline declaration for the data object departure.
At the beginning of the method, add the following code:

Code Snippet

Copy code

Switch to dark mode

  DATA(departure)   = airports[ airportID = details-departureairport ].
Similarly, read the details of the destination airport into a structured data object destination.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

  DATA(departure)   = airports[ airportID = details-departureairport   ].
  DATA(destination) = airports[ airportID = details-destinationairport ].
Use the component name of the two structures to add the airport names to the output.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode

    APPEND |Departure:   { details-departureairport   } { departure-name   }| TO r_output.
    APPEND |Destination: { details-destinationairport } { destination-name }| TO r_output.
Optional: Omit the structured data object and use the table expressions directly in the string templates.

Comment the code lines where you fill the structures departure and destination.

In the string template replace departure-name with airports[ airportid = details-departureairport ]-name.

Similarly replace destination-name with airports[ airportid = details-destination ]-name.

Activate the class. Execute it and analyze the console output. Check that the output displays data for all attributes.

Press Ctrl + F3 to activate the class.

Press F9 to run the class.

Exploring the Architecture
Objectives

After completing this lesson, you will be able to:
Create a database table.
Generate the development objects for an OData UI service.
Creation of the Data Model
Example Data Model

The data model in this example is very simple - there is a single database table that contains details of flight connections - an airline, flight number, details of the departure airport and the destination.

Note

Not included in the figure are additional fields that the runtime needs in order to manage concurrency control. We will look at these a little later on.

Creating a Database Table
First, let's see how to create a database table.

Defining Basic Table Attributes
We will now see how to define basic table attributes.

Adding Table Definition
The following video show how to add table definition.


If you do not use a built-in ABAP Dictionary type to specify the type of a table column, use a data element instead. Data elements are ABAP Dictionary objects that define the type of a single field such as UUID, or airline code. Data elements contain not only a technical type description but also semantic information such as field labels. If you use data elements to define the types of the table columns, the system can use the field labels automatically on the generated user interface.

The data element in the Data Element figure describes the airline field. It is a character field with length 3; the system will use the field labels automatically on the generated UI.


To create a new data element, choose File→New→Other, then type data element into the Filter Text field. Enter a package name and the name of the data element, then choose Next. Select a transport request and choose Finish.

You must then specify a data type for the data element. This should be a domain - the example re-uses the existing domain /DMO/CITY. Note that both data elements use the same domain. This means that if someone subsequently changes the length of the domain, the change applies to all data elements that use it.

Finally, you enter short, medium, and long field labels, and a label that is used for column headings. Later on, when you generate the Fiori Elements app, the system will use these texts automatically.


Each table that you define must have a primary key. This is a sequence of fields at the beginning of the table description that identifies each entry in the table uniquely.

The first field in the table (and therefore also the first field in the key definition) must be the client field, and this must have the data type abap.clnt. Furthermore, it is convenient for our example to use a UUID for the unique key. If you use the data element sysuuid_x16 to specify the type of this field, you can let the runtime assign the UUID automatically when you create a new record.


For traceability reasons it is recommended to store some administrative information with the data, like, for example, the user that created or changed the data and timestamps for the creation and the last change. The database table that you create should contain the fields displayed in the figure.

Note

These fields are mandatory for the generator we are going to use later. For that generator to work properly the fields also have be defined with the data types listed here.

Especially fieldslocal_last_changed_at and last_changed_at are not only administrative fields. In the ABAP RESTful application programming model they are also used for concurrency control.

Because RESTful applications are stateless, data consistency cannot be ensured by exclusive locks alone. The ABAP RESTful application programming model uses a mixture of exclusive locks and ETags to avoid data inconsistencies. An ETag is a field that changes its value whenever a data set is updated. By comparing the value of the ETag field, the framework can ensure that a data set has not been changed since it was read the last time. Timestamps of the last change make perfect ETag fields.


When you activate a database table in ADT, the system creates the corresponding physical table in the database. Once you have done this, you will be able to generate the additional objects that you need for your app automatically.

How to Create Data Elements
Demo
Start Demo
How to Create a Database Table
Demo
Start Demo
Copy a Database Table
In the exercises of this unit, you will create an OData UI service. This UI service will form the basis for an application that allows you to change the price of flights. Firstly, you create a dedicated package for the required development objects. Then you copy a database table and fill it with data.

Template:
/LRN/S4D400_APT (Database Table)
/LRN/CL_S4D400_APT_COPY (global Class)
Solution:
/LRN/S4D400AFLGT (Database Table)
/LRN/CL_S4D400_APS_COPY (global Class)
Task 1: Create Subpackage
Create a new subpackage under your own package ZS4D400_## (where ## stands for your group number).

The subpackage should have the following attributes:

Attribute	Value
Name	ZS4D400_##_RAP, where ## stands for your group number
Description	Objects for OData UI Service
Add to Favorite Packages	Checked
Superpackage	ZS4D400_##, where ## stands for your group number
Package Type	Development
Software Component	ZLOCAL
Application Component	CA
Transport Layer	 
Steps
Create a sub package under your own package ZS4D400_## (where ## stands for your group number).

In the Project Explorer, right-click on your ABAP package ZS4D400_## and choose New→ABAP Package.

Enter the package name ZS4D400_##_RAP, where ## stands for your group number.

Enter the description Objects for OData UI Service.

Mark the checkbox Add to favorite packages.

Ensure that the Superpackage field contains the name of your already existing package.

Ensure that the Package Type is set to Development.

Choose Next.

Ensure that the Software Component is set to ZLOCAL.

Enter the Application component CA.

Ensure that the Transport Layer field is empty.

Choose Next.

Confirm the transport request and choose Finish.

Task 2: Copy Database Table
In the new package, create a copy of the database table /LRN/S4D400_APT. Name the new database table Z##FLIGHT, where ## stands for your group number.

Steps
Copy database table /LRN/S4D400_APT to your own package ZS4D400_##_RAP, where ## stands for your group number.

Open the definition of the database table /LRN/S4D400_APT .

Link the Project Explorer view with the editor.

In the Project Explorer view, right-click database table /LRN/S4D400_APT to open the context menu.

From the context menu, choose Duplicate....

Enter the name of your package ZS4D400_##_RAP in the Package field. In the Name field, enter Z##FLIGHT, where ## stands for your group number.

Choose Next.

Confirm the transport request and choose Finish.

Activate the database table definition.

Press Ctrl + F3 to activate the development object.

Task 3: Fill Database Table
In your ZS4D400_## package, create a copy of the global class /LRN/CL_S4D400_APT_COPY (suggested name: ZCL_##_COPY). In this copy, change the value of the constant table_name to the name of your own database table. Then execute the class as a console app. This will fill your database table with data.

Steps
Copy the class /LRN/CL_S4D400_APT_COPY to a class in your own package ZS4D400_##.

Open the source code of the global class /LRN/CL_S4D400_APT_COPY.

If necessary, link the Project Explorer view with the editor.

In the Project Explorer view, right-click the class /LRN/CL_S4D400_APT_COPY to open the context menu.

From the context menu, choose Duplicate....

Enter ZS4D400_## in the Package field. In the Name field, enter ZCL_##_COPY, where ## stands for your group number.

Choose Next.

Confirm the transport request and choose Finish.

In the copy, adjust the source code of the method IF_OO_ADT_CLASSRUN~MAIN. Change the value of the constant table_name to the name of your own database table.

Make sure the value of the constant equals the name of your database table.

Activate and execute the class as a console app.

Press Ctrl + F3 to activate the class.

Press F9 to run the class.

Check the Console view. The last output should read: <...> was filled with data. If the output reads <...> is not a table of the right type. make sure a database table of that name exists, is active, and is an exact copy of the template table.

The Object Generator
Generating Additional Objects
We have just defined a database table to hold our data, but the app that we are going to create needs more objects than just this table. We can generate these objects using a wizard in ADT.


The generated objects contain all of the information that is necessary to provide a working app with create, read, update, and delete capability. Later on, we will also adjust and extend some of these objects to change the appearance of the user interface and to implement some checks and calculations.

Watch this video to learn how to generate additional objects.

How to Generate the Additional Objects
Demo
Start Demo
Preview of the OData UI Service
Publish and Preview the Service
Using your database table and the object generator, you can generate all of the objects that you need to get a working Fiori Elements app. The only manual step is to publish the service.


You must publish the service before you can test the app. To do so, open the service binding and choose Publish. Once you have done this, the entity that you created (in this case, Connection) appears in the list of entities. Mark it and choose Preview to test the app.

Test the App

When you choose Preview, a browser window opens and you can create a new flight connection. However, the app does not implement any checks other than type checks (for example, only digits are allowed in the Flight Number field).

Generate and Preview an OData UI Service
In this exercise, you generate the repository objects for an OData UI service and preview the service as an SAP Fiori app.

Template:
none
Solution:
The generated development objects in package /LRN/S4D400_EXERCISE_RAP.
Note

Please note that the implementation of the generator used may change. Therefore, the development objects generated in the exercise may differ from those in the solution.
Prerequisites
You completed the previous exercise. You created the database table Z##FLIGHT (where ## is your group number) and the database table contains data.

Task 1: Use the Generator
Use the generator ABAP RESTful Application Programming Model→OData UI Service to generate the required development objects in your subpackage ZS4D400_##_RAP. To do this, specify the following values ​​in the wizard:

Field	Value
General→Referenced Object	Z##FLIGHT
General→Project Name	<empty>
General→Artifacts Prefix	<empty>
General→Artifacts Suffix	<empty>
 	 
Business Object→Data Model→CDS Entity Name	ZR_##Flight
Business Object→Data Model→CDS Entity Alias	Flight
Business Object→Behavior→Behavior Implementation Class	ZBP_R_##FLIGHT
Business Object→Behavior→Draft Table Name	Z##FLIGHT_D
 	 
Service Projection→Service Projection Entity→CDS Entity Name	ZC_##Flight
Service Projection→Service Projection Behavior→Behavior Implementation Class	ZBP_C_##FLIGHT
 	 
Business Service→Service Definition→Service Definition Name	ZUI_##FLIGHT_O4
Business Service→Service Binding→Service Binding Name	ZUI_##FLIGHT_O4
Business Service→Service Binding→Binding Type	OData V4 - UI
Steps
Start the object generator for your database table Z##FLIGHT (where ## is your group number).

In the Project Explorer, expand the following path: Favorite Packages→ZS4D400_##→ZS4D400_##_RAP→Dictionary→Database Tables (where ## is your group number). Alternatively, open the definition of database table Z##FLIGHT and, if necessary, link the Project Explorer view with the editor.

In the Project Explorer view, right-click database table Z##FLIGHT to open the context menu.

From the context menu, choose Generate ABAP Repository Objects....

In the dialog box, select the generator.

On the left-hand side of the dialog box, choose ABAP RESTful Application Programming Model→OData UI Service.

Choose Next to navigate to the next step.

Ensure that the development objects are created in your subpackage ZS4D400_##_RAP.

When the window reads Enter Package at the top, ensure that the Package field contains ZS4D400_##_RAP.

Choose Next to navigate to the next step.

Configure the generator with the data from the table.

Caution

Do not choose Next before you have entered all data.
Select the items on the left side of the dialog box one by one and fill in the corresponding fields in the right pane. The required values ​​are listed in the table above.

After you entered all data choose Next.

Check the repository objects that are going to be generated and generate the objects.

Note

Be patient. Generating the objects takes some time. At the end of the generation process, a dialog box appears asking if you want to open the generated Service Binding in the editor. Confirm this dialog by clicking Open.
Check the list of repository objects that are displayed.

When you are sure you have entered all names correctly choose Next.

Confirm the transport request and choose Finish.

Confirm the dialog window at the end of the generation process by choosing Open.

Analyze the generator output in the Project Explorer.

In the Project Explorer, place the cursor on your subpackage ZS4D400_##_RAP and press F5 to reload the content of the package.

Expand all subnodes of the package to see the names of the generated development objects.

Task 2: Preview the App
Publish the OData UI service and preview the result as an SAP Fiori app.

Steps
Publish the local service endpoint.

Note

Publishing the service may take some time.
If you have not already, open the generated ZUI_##FLIGHT_O4 Service Binding.

If the Service Binding is inactive press Ctrl + F3 to activate it.

To publish the service, choose Publish in the center of the editor.

Preview the OData UI service as an SAP Fiori app.

In the Service Version Details section on the right-hand side, choose Flight and then Preview....

Result
A browser window opens with an SAP Fiori application. If prompted, log on to the application with your ABAP system user.
Display the list of flights.

Choose Go to display the list of flights that are stored in your database table Z##FLIGHT.

For one of the flights, navigate to the details view.

Choose one of the list entries to navigate to the Object Page with details of that flight.

For this flight, switch to change mode.

Choose Edit.

Enter some text in the field Flight Price, for example a.

Enter a negative value for the Flight Price.

Adding ABAP logic
Objective

After completing this lesson, you will be able to implement the behavior of a Business Object.
Validations
Checking the Semantic Key

In the ABAP RESTful application programming model, the key of a database table is often made up of the client field and a UUID field, whose value is assigned automatically by the runtime when you create a new instance of the business object. This field combination is sufficient to ensure that the system can identify each record in the table uniquely. However, as well as this technical key, our object also has a semantic key - in this case the combination of airline and flight number, which must also be unique according to the business logic. In order to ensure the uniqueness of this field combination, you must implement your own check in the form of a validation.

You declare validations in the behavior definition of the CDS view entity, and implement them in the behavior implementation class.

Input Checks in the App
As well as checking the semantic key, there are other checks that you need to perform. For example, although the generated app allows you to create, read, update and delete data, it does not yet contain any consistency checks. Consequently, you can create flight connections for airlines that don't exist, or where the departure and destination airports are the same.


To prevent this from happening, you define further validations in the behavior definition, and implement them in the behavior implementation class.

Creating Message Texts
Before you create the validation, you must create the texts that you want to display. You do this using a message class. A message class is a collection of up to 1000 messages that belong to a particular application area. As shown in the figure, each text has a number which identifies the message uniquely within the message class.


To create a new message class, proceed as follows:

Choose File→New→Other… and type message into the filter field.

Double-click the Message Class entry in the hit list, then enter a package, name, and description for the new message class. Choose Next.

Assign the message class to a transport request and choose Finish.

Messages can also contain placeholders, which are replaced with concrete values when the message is displayed. Placeholders are denoted by the ampersand symbol followed by a number. You can use up to four placeholders in each message.

Defining the Validation
To define a validation, you add a validation declaration to the behavior definition of your business object. In this example, the validation should be performed whenever the user saves a data record, and this could be either when they create the record or if they subsequently change it.


When you define the validation in the behavior definition, a warning tells you that the corresponding method does not exist. Use a quick fix (key combination CTRL + 1) to add the method to the behavior implementation. The behavior implementation is a local class within your behavior pool. The method definition contains the addition FOR VALIDATE ON SAVE, which identifies it as the implementation of the validation. It has an importing parameter KEYS. This is an internal table containing the keys of the created or changed objects. You use these to read the actual data that the user has entered.

The addition FOR Connection~CheckSemanticKey links the method with the validation CheckSemanticKey from the behavior definition. Here, Connection is the alias name of the view entity Z_R_CONNECTION.


When you define a validation, you must also create its implementation. This is a method in the behavior pool. The easiest way to do this is to use a quick fix. Position the cursor on the name of the validation and press CTRL + 1. ADT proposes to create the method. Double-click the proposal to create the method.

The Validation Process
Note

Some code examples in this section use SELECT statements inside of loops. This has been done to keep the examples simple. Note that SELECTs in loops can cause performance problems and should be avoided.

When the system triggers a validation, it calls the corresponding implementation. The importing parameter KEYS contains the keys of the data records that have been changed. You use the keys to read the fields of the records that you need using Entity Manipulation Language (EML). EML is a special set of statements in ABAP that allows you to address business objects.

Once you have read the data, you can perform the checks that you need. If the check fails, you will need to issue an appropriate error message and, importantly, tell the framework not to write the changes to the database.


The first task in a validation is to read the user input. You do this using the Entity Manipulation Language (EML) statement READ ENTITIES. The keys of the new data records are passed to the validation using the importing parameter keys.

The fields that you need to validate the semantic key are CarrierID for the airline and ConnectionID for the flight number. You also need the UUID field.

The code snippet uses the corresponding operator and an inline declaration for the result set. Below, you see the equivalent code using explicitly-defined variables, which makes it easier to understand the types that are used.

Code Snippet

Copy code

Switch to dark mode

DATA read_keys   TYPE TABLE FOR READ IMPORT zs4d400_r_connection.
DATA connections TYPE TABLE FOR READ RESULT zs4d400_r_connection. 

read_keys = CORRESPONDING #( keys ). 

READ ENTITIES OF zs4d400_r_connection IN LOCAL MODE
       ENTITY Connection
       FIELDS ( uuid CarrierID ConnectionID ) 
         WITH read_keys
       RESULT connections. 

Once you have read the user input, you can use the values of CarrierID and ConnectionID to see if this semantic key has already been used in another data set than the one you are processing just now. Since the key combination could be in either the active table or the draft table, you need to look in both, and the most efficient way to do this is with a union.


The result set of this query should always be empty. If not, there are more records with the same combination of CarrierID and ConnectionID, this means that the record that the user is currently trying to create is a duplicate, and must be rejected.


If the combination of carrier ID and connection ID already exists, there will be an entry in the table check_result. In this case, you must issue a message.

The first step is to create a message object. You do this using the self-reference me and calling the method new_message( ). The parameters ID, number, and severity are mandatory. ID is the name of the message class that contains the message; number is the message number. Severity classifies the message as a success, information, warning, or error message. The behavior implementation class contains a structured constant ms whose components represent the different severity levels. In this case, you need the severity level ms-error.

The method also has optional importing parameters v1, v2, v3, and v4. You use these to replace placeholders with concrete values. In this example, the placeholder &1 is replaced with the airline code, placeholder &2 is replaced with the flight number.

The result of the method call is an object reference. In the next step, you will pass the object to the runtime so that the error message is returned the OData service and displayed in the app preview.


To make the runtime display a message, you must report it using the reported structure. This is an implicit changing parameter of all validation methods and is a deep structure. It contains a component with the alias name of the business object. This component is an internal table.

To report the message, you must do three things:

Add the key of the affected record to the internal table. You can do this using the field group %tky. When you group fields like this, you can address the name of the group instead of having to address each field individually.
Attach the message object to the table. You do this by assigning the object reference of the message object to the %msg component of the internal table.
Bind the message to the affected field. This ensures that the field is emphasized in the app. This, in turn, helps the user to navigate the app better. You do this using the %element component of the internal table.

In this example, reported_record is a structure with the line type of the internal table reported-connection. You fill the %tky component with the contents of the %tky field group in the data record. This is the structure line that we used as a work area for the internal table containing the data that the user entered. Next, you assign the message object that you created using the new_message( ) method to the %msg component. Finally, to bind the message to the field CarrierID, you use the structure %element. %element is a structure, and contains a component for each element in the view entity. If you set a component to "true", the corresponding input field will be highlighted in the app. You do this using the structured constant if_abap_behv=>mk. This has the component on for checked/true and off for unchecked/false.

You cannot use the global constants abap_true and abap_false at this point, as their data types are not compatible.


As well as issuing the message, you must also tell the runtime not to save the incorrect data. To do this, you use the failed structure of the validation method. Failed is an implicit changing parameter that is present in all validation methods.

To report a record as failed, add its field group %tky to the field group %tky of the internal table failed-Connection.


The next validation checks that the airline that the user has entered actually exists. The first step is to read the user input using the EML statement READ ENTITIES. This time, you only need to read the field CarrierID.


The SELECT SINGLE statement reads data using the CDS view entity /dmo/i_carrier and checks whether the given airline exists. If it does, the value of the global constant abap_true ('X') is placed in the field exists. If exists is initial following the SELECT statement, you must issue a message, report it, and add the record to the failed structure as you did in the previous example.

The final validation checks that the origin and destination airports are different. The first step is to read the user input using a READ ENTITIES statement. This time, the fields AirportFromID and AirportToID are relevant.



If the departure and arrival airports are the same, you must issue the corresponding message and fill the reported and failed structures. The code extract shows the relevant coding to create the message. The coding to fill the reported and failed structures is the same as in the previous examples.

How to Validate the Semantic Key
Demo
Start Demo
Determinations
Determine Cities Based on Airport Codes
In the example app, the flight connection entity contains a departure airport, city, and country, and an arrival airport, city, and country. While it would be possible to force the user to enter all of this information, it is better in terms of user experience and data consistency to have the user enter only the airport codes and for the app to read the corresponding city and country information from the database. In the ABAP RESTful application programming model, you can perform this kind of task using a determination.


You will first implement the determination. Afterwards, you will learn how to deactivate input for the fields that will be filled automatically.

Defining the Determination
You define a determination in the behavior definition of a business object. The determination here is called getCities, it will be called whenever the business object is saved and at least one of the AirportFromID and AirportToID fields has changed. You can use a quick fix in the behavior definition to create the corresponding method in the behavior implementation.


The Determination Process
Let's explore each step of the determination process.


When the system triggers a determination, it calls the corresponding implementation. The importing parameter KEYS contains the keys of the data records that have been changed. In the determination method, you use EML to read the data based on the keys in exactly the same way that you did in the validations. However, in a determination, you also manipulate the data in the method and you must consequently update the data held by the framework using the EML statement UPDATE.

Note

Some code examples in this section use SELECT statements inside of loops. This has been done to keep the examples simple. Note that SELECTs in loops can cause performance problems and should be avoided.

At the beginning of the determination you read the user input using EML. You need the AirportFromID and AirportToID fields and will use these to complete the city and ciountry information.


The demonstration data model provides a CDS view entity /dmo/i_airport that you can use to read the city and country in which a particular airport is located. The example uses the variant of the INTO clause in which you explicitly specify the fields of the structure that you want to fill. Remember that the changes to the data are in the work area of the internal table and that you must return them to the table itself using the MODIFY statement.


The READ ENTITIES statement returns an internal table with the derived type FOR READ RESULT. To change the data in the transactional buffer, you need a MODIFY ENTITIES statement. You pass the data that you want to change to this statement using an internal table with the derived type FOR UPDATE. The data fields are identical in both types, however the FOR UPDATE table has an additional structure called %control that contains administrative information.

You cannot pass the connections table to the MODIFY ENTITIES statement. You therefore need to copy your data into an appropriately-typed internal table (connections_upd) before you perform the actual modification.


To update the data with the fields that you filled in the determination, you use the MODIFY ENTITIES statement. In it, you specify which fields should be updated in the FIELDS clause, and pass the data in an internal table using the WITH addition. This table must have the correct derived data type, which in this case would be TYPE TABLE FOR UPDATE zsd4d400_r_connection.

The MODIFY ENTITIES statement can return messages, which you receive using the REPORTED clause. You then propagate these messages to your own business object by copying the contents of the internal table to the REPORTED structure of the determination method.

How to Determine the Cities and Countries
Demo
Start Demo
Validate the Flight Price
In this exercise you define and implement a validation for the flight price.

Template:
none
Solution:
/LRN/S4D400_R_FLIGHT (Behavior Definition)
/LRN/BP_S4D400_R_FLIGHT (Global Class)
Prerequisites
You completed the previous exercises. You created and filled the database table Z##FLIGHT (where ## is your group number) and generated the development objects for an OData UI service.

Task 1: Validate the Price
Define and implement a validation to check that the field Price has a positive value (suggested name: validatePrice). If the value is negative or equals zero, reject the change and report a suitable error message from message class /LRN/S4D400.

Steps
In the behavior definition ZR_##FLIGHT, define a new validation validatePrice. Ensure that the validation is always executed during the standard operation create but only if the value of Price changed for all other operations.

Hint

Use code-completion wherever possible to enter the code.
Open the behavior definition ZR_##FLIGHT.

Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode
create;
update;
delete;

validation validatePrice on save { create; field Price; }
Activate the behavior definition.

Press Ctrl + F3 to activate the behavior definition.

Use a quick fix to create the validation implementation method in the behavior handler class.

Position the cursor on the name of the validation and choose Ctrl + 1.

Double-click the entry Add method for validation....

At the beginning of the validatePrice method, declare a structured data object that you type with the line type of failed-flight (suggested name: failed_record). Similarly, declare a structured data object that you type with the line type of reported-flight (suggested name: reported_record).

Note

These structures will be used to add rows to failed-flight and reported-flight, in case the validation finds an error.
Add the following code:

Code Snippet

Copy code

Switch to dark mode
DATA failed_record   LIKE LINE OF failed-flight.
DATA reported_record LIKE LINE OF reported-flight.
Use a READ ENTITIES statement to read the user input from the transactional buffer. Use the IN LOCAL MODE addition and ensure that only the key fields and the field Price are read. Use an inline declaration for the result set (suggested name: flights).

Note

It is not necessary to list the key fields after the FIELDS addition. READ ENTITIES always reads the key fields.
After the declarations, add the following code, replacing ## with your group number:

Code Snippet

Copy code

Switch to dark mode
READ ENTITIES OF ZR_##Flight IN LOCAL MODE
  ENTITY Flight
    FIELDS ( Price )
    WITH CORRESPONDING #(  keys )
    RESULT DATA(flights).
Implement a loop over the data that you just read. Use an inline declaration for the work area (suggested name: flight).

After the EML statement, add the following code:

Code Snippet

Copy code

Switch to dark mode
LOOP AT flights INTO DATA(flight).
  
ENDLOOP.
Inside the loop, check if the Price component is greater than zero. If not, fill the structure failed_record with the key of the current flight and add it as new row to table failed-flight. Similarly, fill structure reported_record with the key of the current flight and add it as new row to table reported-flight.

Hint

In draft-enabled business objects, it is recommended that you use the component %tky to assign the key.
Inside the loop, add the following code:

Code Snippet

Copy code

Switch to dark mode
IF flight-price <= 0.

  failed_record-%tky = flight-%tky.
  APPEND failed_record TO failed-flight.

  reported_record-%tky = flight-%tky.
  APPEND reported_record TO reported-flight.
ENDIF.
Before the APPEND statement fill the %msg component of the reported_record structure with a reference to a message object. To create the message object, call the method new_message with the following input:

Parameter name	Value
id	'/LRN/S4D400'
number	'101'
severity	ms-error
Adjust the code as follows:

Code Snippet

Copy code

Switch to dark mode
LOOP AT flights INTO DATA(flight).
  IF flight-price <= 0.

    failed_record-%tky = flight-%tky.
    APPEND failed_record TO failed-flight.

    reported_record-%tky = flight-%tky.
    reported_record-%msg = new_message(
                      id       = '/LRN/S4D400'
                      number   = '101'
                      severity = ms-error ).
    APPEND reported_record TO reported-flight.

  ENDIF.
ENDLOOP.
Activate the class.

Press Ctrl + F3 to activate the class.

Task 2: Test and Debug
Set a breakpoint in the validation implementation. Restart the preview of the OData UI service and change the price of an existing flight. Make valid and invalid entries, and debug the validation.

Steps
Set a breakpoint at the READ ENTITIES statement of the validatePrice method.

In the implementation of the validatePrice method, find the READ ENTITIES statement and double-click the area to the left of the row number to set a breakpoint.

Restart the preview of the OData UI service.

Close the browser window or browser tab that contains the preview.

Open the ZUI_##FLIGHT_O4 Service Binding. In the Entity Set and Association list on the right-hand side, first choose the Flight entry and then choose Preview....

In the app, display the list of flights, open the details for one of the flights and switch to change mode.

Proceed as you have done in previous exercises.

Make some changes to the price, and then choose Save. Analyze the validation in the debugger.

Proceed as you have done in previous exercises.